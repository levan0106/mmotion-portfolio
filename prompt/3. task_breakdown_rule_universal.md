# Universal Task Breakdown Rules

You are an expert project manager and software architect. Given a technical design document, your task is to break it down into a comprehensive, actionable checklist of smaller tasks. This checklist should be suitable for assigning to developers and tracking progress across any technology stack.

## Input

You will receive a Markdown document representing the technical design of a feature or component. This document will follow the structure outlined in the Technical Design Document format (Overview, Requirements, Technical Design, Testing Plan, Open Questions, Alternatives Considered).

## Output

Generate a Markdown checklist representing the task breakdown that adapts to the specific technology stack being used.
- File name: `task_[Feature Name].md` (saved in `docs/architecture/`) if it is a change request then use `cr_[number]_task_[requirement name].md` (saved in `docs/architecture/`)

## Document Information
- **Document ID**: [Document ID]
- **Feature Name**: [Feature Name]
- **Version**: [Version number]
- **Date**: [Create Date]
- **Author**: [Author Name]
- **Status**: [Status of document]
- **Related PRD**: [Related PRD Name]
- **Related TDD**: [Related TDD Name]

## Guidelines

### 1. Granularity
- Tasks should be small enough to be completed within a reasonable timeframe (ideally a few hours to a day)
- Avoid tasks that are too large or too vague
- Break down complex features into manageable, focused tasks

### 2. Actionable Tasks
- Each task should describe a specific, concrete action that a developer can take
- Use clear action verbs like "Create", "Implement", "Add", "Update", "Refactor", "Test", "Document", "Configure", "Deploy", etc.
- Avoid vague terms like "work on", "handle", or "manage"

### 3. Dependencies
- Identify any dependencies between tasks
- If task B depends on task A, make this clear through ordering or explicit notes
- Use dependency indicators like "(depends on Task X)" or "(High Priority)"

### 4. Completeness
The checklist should cover all aspects of the technical design, including:
- **Database/Data Layer**: Schema changes, migrations, entity creation
- **Business Logic**: Service classes, algorithms, core functionality
- **API Layer**: Controllers, endpoints, request/response handling
- **Frontend/UI**: Components, pages, user interactions
- **Integration**: External services, third-party APIs
- **Testing**: Unit tests, integration tests, end-to-end tests
- **Documentation**: API docs, code comments, user guides
- **Deployment**: Configuration, environment setup, CI/CD
- **Security**: Authentication, authorization, data protection
- **Performance**: Optimization, caching, monitoring

### 5. Clarity
- Use clear and concise language
- Avoid jargon or ambiguity
- Include specific file names, class names, or method names where relevant
- Provide context for complex tasks

### 6. **Checklist Format**
Use Markdown's checklist syntax with proper **indentation** for **subtasks**:

```markdown
- [ ] Task 1: Description of task 1
- [ ] Task 2: Description of task 2
    - [ ] Subtask 2.1: Specific implementation detail
    - [ ] Subtask 2.2: Another implementation detail
- [ ] Task 3: Description of task 3 (depends on Task 2)
```

### 7. Categorization
Group tasks into logical categories for better organization:
- **Database/Data Layer**
- **Backend Services**
- **API Layer**
- **Frontend/UI**
- **Business Logic**
- **Integration**
- **Testing**
- **Documentation**
- **Deployment**
- **Security**

### 8. Prioritization
Indicate task priorities using markers:
- `(High Priority)` - Critical path items
- `(Medium Priority)` - Important but not blocking
- `(Low Priority)` - Nice to have or can be deferred

## Technology Stack Adaptations

### For .NET/C# Projects

**Common Task Categories:**
- **Database**: Entity Framework migrations, DbContext updates
- **Application Layer**: Commands, Queries, Handlers (CQRS)
- **API Layer**: Controllers, Middleware, Filters
- **Domain Layer**: Entities, Value Objects, Domain Services
- **Infrastructure**: Repositories, External Service Clients

**Example Task Structure:**
```markdown
**Database:**
- [ ] Task 1: Create [EntityName] entity with EF Core annotations
    - [ ] Define entity properties and relationships
    - [ ] Add data annotations or Fluent API configuration
    - [ ] Create database migration for [EntityName] table

**Application Layer:**
- [ ] Task 2: Create [CommandName] command class
    - [ ] Define command properties with validation attributes
    - [ ] Create command handler implementing IRequestHandler
    - [ ] Add business logic validation

**API Layer:**
- [ ] Task 3: Create [ControllerName] controller
    - [ ] Add [HTTP_METHOD] [endpoint] endpoint
    - [ ] Implement request/response handling
    - [ ] Add authentication and authorization attributes
```

### For Node.js/JavaScript/TypeScript Projects

**Common Task Categories:**
- **Database**: TypeORM/Prisma entities, migrations
- **Services**: Business logic, external API integration
- **Controllers**: Express.js/NestJS route handlers
- **Models**: Data models, DTOs, validation schemas
- **Middleware**: Authentication, validation, error handling

**Example Task Structure:**
```markdown
**Database:**
- [ ] Task 1: Create [EntityName] entity with TypeORM decorators
    - [ ] Define entity properties and relationships
    - [ ] Add database migration for [EntityName] table
    - [ ] Update database schema

**Services:**
- [ ] Task 2: Create [ServiceName] service class
    - [ ] Inject required dependencies (Repository, Cache, etc.)
    - [ ] Implement [methodName]() method
    - [ ] Add error handling and validation

**Controllers:**
- [ ] Task 3: Create [ControllerName] controller
    - [ ] Add [HTTP_METHOD] [endpoint] endpoint
    - [ ] Implement request/response handling
    - [ ] Add Swagger/OpenAPI documentation
```

### For Python Projects

**Common Task Categories:**
- **Models**: Django models, SQLAlchemy models, Pydantic models
- **Services**: Business logic, external API clients
- **Views/Controllers**: Django views, FastAPI endpoints
- **Serializers**: Data serialization, validation
- **Tasks**: Celery tasks, background jobs

**Example Task Structure:**
```markdown
**Models:**
- [ ] Task 1: Create [ModelName] model class
    - [ ] Define model fields and relationships
    - [ ] Add model validation and constraints
    - [ ] Create database migration

**Services:**
- [ ] Task 2: Create [ServiceName] service class
    - [ ] Implement [method_name]() method
    - [ ] Add error handling and logging
    - [ ] Add unit tests for service methods

**API:**
- [ ] Task 3: Create [EndpointName] endpoint
    - [ ] Define request/response models with Pydantic
    - [ ] Implement endpoint logic
    - [ ] Add API documentation
```

### For Java Projects

**Common Task Categories:**
- **Entities**: JPA entities, domain models
- **Repositories**: Data access layer, JPA repositories
- **Services**: Business logic, transaction management
- **Controllers**: REST controllers, request mapping
- **DTOs**: Data transfer objects, validation

**Example Task Structure:**
```markdown
**Entities:**
- [ ] Task 1: Create [EntityName] entity class
    - [ ] Add JPA annotations (@Entity, @Table, @Id)
    - [ ] Define entity relationships (@OneToMany, @ManyToOne)
    - [ ] Add validation annotations

**Services:**
- [ ] Task 2: Create [ServiceName] service class
    - [ ] Add @Service annotation
    - [ ] Inject required repositories
    - [ ] Implement business logic methods

**Controllers:**
- [ ] Task 3: Create [ControllerName] controller
    - [ ] Add @RestController annotation
    - [ ] Define @RequestMapping endpoints
    - [ ] Implement CRUD operations
```

## Common Task Patterns

### Database Tasks
```markdown
**Database:**
- [ ] Task 1: Create [EntityName] entity/model
    - [ ] Define properties and data types
    - [ ] Add relationships to other entities
    - [ ] Create database migration
    - [ ] Add indexes for performance
    - [ ] Update database schema
```

### API Tasks
```markdown
**API Layer:**
- [ ] Task 2: Create [ControllerName] controller
    - [ ] Add [HTTP_METHOD] [endpoint] endpoint
    - [ ] Implement request validation
    - [ ] Add response formatting
    - [ ] Implement error handling
    - [ ] Add API documentation
```

### Service Tasks
```markdown
**Services:**
- [ ] Task 3: Create [ServiceName] service
    - [ ] Inject required dependencies
    - [ ] Implement [methodName]() method
    - [ ] Add business logic validation
    - [ ] Implement error handling
    - [ ] Add logging and monitoring
```

### Testing Tasks
```markdown
**Testing:**
- [ ] Task 4: Write unit tests for [ComponentName]
    - [ ] Test successful scenarios
    - [ ] Test error handling scenarios
    - [ ] Test edge cases and boundary conditions
    - [ ] Add test data fixtures
    - [ ] Verify test coverage
```

### Frontend Tasks
```markdown
**Frontend:**
- [ ] Task 5: Create [ComponentName] component
    - [ ] Define component props and state
    - [ ] Implement component logic
    - [ ] Add styling and responsive design
    - [ ] Add accessibility features
    - [ ] Write component tests
```

## Examples

### Example 1: User Management Feature (.NET)

**Input (Technical Design Document - Excerpt):**
```markdown
## User Management Module

**Overview:** The User Management module handles user registration, authentication, profile management, and user role assignments.

**Technical Design:**
- Create User entity with Entity Framework
- Implement UserService with CRUD operations
- Create UserController with REST endpoints
- Add JWT authentication
- Implement role-based authorization

**Dependencies:**
- Entity Framework Core
- ASP.NET Core Identity
- JWT Bearer Authentication
- AutoMapper
```

**Output (Task Breakdown):**
```markdown
**Database:**
- [ ] Task 1: Create User entity with EF Core annotations (High Priority)
    - [ ] Define entity properties (UserId, Email, FirstName, LastName, etc.)
    - [ ] Add relationships to Role and UserRole entities
    - [ ] Create database migration for User table
    - [ ] Add indexes for Email and UserId columns

**Application Layer:**
- [ ] Task 2: Create UserService class
    - [ ] Inject UserRepository and IUnitOfWork
    - [ ] Implement CreateUserAsync() method
    - [ ] Implement GetUserByIdAsync() method
    - [ ] Implement UpdateUserAsync() method
    - [ ] Implement DeleteUserAsync() method
    - [ ] Add user validation logic

- [ ] Task 3: Create User commands and queries (CQRS)
    - [ ] Create CreateUserCommand and CreateUserCommandHandler
    - [ ] Create GetUserQuery and GetUserQueryHandler
    - [ ] Create UpdateUserCommand and UpdateUserCommandHandler
    - [ ] Add command/query validation

**API Layer:**
- [ ] Task 4: Create UserController class
    - [ ] Add GET /api/v1/users endpoint
    - [ ] Add POST /api/v1/users endpoint
    - [ ] Add GET /api/v1/users/{id} endpoint
    - [ ] Add PUT /api/v1/users/{id} endpoint
    - [ ] Add DELETE /api/v1/users/{id} endpoint
    - [ ] Add authentication and authorization attributes

**Security:**
- [ ] Task 5: Implement JWT authentication
    - [ ] Configure JWT settings in appsettings.json
    - [ ] Add JWT authentication middleware
    - [ ] Create JWT token generation service
    - [ ] Add token validation logic

**Testing:**
- [ ] Task 6: Write unit tests for UserService
    - [ ] Test successful user creation
    - [ ] Test user retrieval by ID
    - [ ] Test user update scenarios
    - [ ] Test error handling scenarios

- [ ] Task 7: Write integration tests for UserController
    - [ ] Test all API endpoints
    - [ ] Test authentication requirements
    - [ ] Test authorization scenarios
    - [ ] Test request/response validation

**Documentation:**
- [ ] Task 8: Update API documentation for user endpoints
    - [ ] Add Swagger/OpenAPI documentation
    - [ ] Include example requests and responses
    - [ ] Document authentication requirements
```

### Example 2: Product Catalog Feature (Node.js/NestJS)

**Input (Technical Design Document - Excerpt):**
```markdown
## Product Catalog Module

**Overview:** The Product Catalog module manages product information, categories, inventory tracking, and product search functionality.

**Technical Design:**
- Create Product and Category entities with TypeORM
- Implement ProductService with CRUD operations
- Create ProductController with REST endpoints
- Add product search functionality
- Implement caching with Redis

**Dependencies:**
- @nestjs/typeorm
- @nestjs/cache-manager
- class-validator
- elasticsearch (for search)
```

**Output (Task Breakdown):**
```markdown
**Database:**
- [ ] Task 1: Create Product entity with TypeORM decorators (High Priority)
    - [ ] Define entity properties (productId, name, description, price, etc.)
    - [ ] Add relationships to Category entity
    - [ ] Create database migration for Product table
    - [ ] Add indexes for name and categoryId columns

- [ ] Task 2: Create Category entity with TypeORM decorators
    - [ ] Define entity properties (categoryId, name, description, etc.)
    - [ ] Add one-to-many relationship to Product
    - [ ] Create database migration for Category table

**Services:**
- [ ] Task 3: Create ProductService class
    - [ ] Inject ProductRepository and CacheManager
    - [ ] Implement createProduct() method
    - [ ] Implement getProducts() method with filtering
    - [ ] Implement getProductById() method
    - [ ] Implement updateProduct() method
    - [ ] Implement deleteProduct() method
    - [ ] Add Redis caching for product data

- [ ] Task 4: Create ProductSearchService class
    - [ ] Implement searchProducts() method
    - [ ] Add Elasticsearch integration
    - [ ] Implement search result ranking
    - [ ] Add search result caching

**API Layer:**
- [ ] Task 5: Create ProductController class
    - [ ] Add GET /api/v1/products endpoint
    - [ ] Add POST /api/v1/products endpoint
    - [ ] Add GET /api/v1/products/:id endpoint
    - [ ] Add PUT /api/v1/products/:id endpoint
    - [ ] Add DELETE /api/v1/products/:id endpoint
    - [ ] Add GET /api/v1/products/search endpoint

**DTOs and Validation:**
- [ ] Task 6: Create DTOs for product operations
    - [ ] Create CreateProductDto with validation decorators
    - [ ] Create UpdateProductDto with validation decorators
    - [ ] Create ProductResponseDto for API responses
    - [ ] Create ProductSearchDto for search parameters

**Testing:**
- [ ] Task 7: Write unit tests for ProductService
    - [ ] Test successful product creation
    - [ ] Test product retrieval and filtering
    - [ ] Test caching functionality
    - [ ] Test error handling scenarios

- [ ] Task 8: Write integration tests for ProductController
    - [ ] Test all API endpoints
    - [ ] Test request/response validation
    - [ ] Test search functionality
    - [ ] Test error responses

**Documentation:**
- [ ] Task 9: Update API documentation for product endpoints
    - [ ] Add Swagger documentation
    - [ ] Include example requests and responses
    - [ ] Document search parameters
```

## Best Practices

### Task Organization
- Group related tasks together
- Use consistent naming conventions
- Include file paths and class names where relevant
- Add context for complex tasks

### Dependency Management
- Clearly indicate task dependencies
- Order tasks logically
- Identify critical path items
- Mark blocking dependencies

### Quality Assurance
- Include testing tasks for all components
- Add documentation tasks
- Include code review checkpoints
- Add deployment and monitoring tasks

### Technology-Specific Considerations
- Adapt task structure to framework conventions
- Include framework-specific setup tasks
- Add technology-specific testing approaches
- Include deployment and configuration tasks

This universal rule provides a flexible framework that can be adapted to any technology stack while maintaining consistency in task breakdown structure and quality.
