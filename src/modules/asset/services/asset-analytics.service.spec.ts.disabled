import { Test, TestingModule } from '@nestjs/testing';
import { AssetAnalyticsService } from './asset-analytics.service';
import { IAssetRepository, AssetStatistics } from '../repositories/asset.repository.interface';
import { Asset } from '../entities/asset.entity';
import { AssetType } from '../enums/asset-type.enum';

describe('AssetAnalyticsService', () => {
  let service: AssetAnalyticsService;
  let mockRepository: jest.Mocked<IAssetRepository>;

  const mockAsset1: Asset = {
    id: 'asset-1',
    name: 'Stock Asset',
    code: 'STOCK1',
    type: AssetType.STOCK,
    description: 'Stock asset',
    initialValue: 1000000,
    initialQuantity: 100,
    currentValue: 1200000,
    currentQuantity: 100,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    createdBy: 'user-1',
    updatedBy: 'user-1',
    portfolioId: 'portfolio-1',
    trades: [],
    portfolioAssets: [],
    getTotalValue: jest.fn().mockReturnValue(1200000),
    getTotalQuantity: jest.fn().mockReturnValue(100),
    hasTrades: jest.fn().mockReturnValue(false),
    getDisplayName: jest.fn().mockReturnValue('Stock Asset (STOCK1)'),
    toJSON: jest.fn().mockReturnValue({}),
  };

  const mockAsset2: Asset = {
    id: 'asset-2',
    name: 'Bond Asset',
    code: 'BOND1',
    type: AssetType.BOND,
    description: 'Bond asset',
    initialValue: 2000000,
    initialQuantity: 200,
    currentValue: 2100000,
    currentQuantity: 200,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    createdBy: 'user-1',
    updatedBy: 'user-1',
    portfolioId: 'portfolio-1',
    trades: [],
    portfolioAssets: [],
    getTotalValue: jest.fn().mockReturnValue(2100000),
    getTotalQuantity: jest.fn().mockReturnValue(200),
    hasTrades: jest.fn().mockReturnValue(false),
    getDisplayName: jest.fn().mockReturnValue('Bond Asset (BOND1)'),
    toJSON: jest.fn().mockReturnValue({}),
  };

  const mockAsset3: Asset = {
    id: 'asset-3',
    name: 'Gold Asset',
    code: 'GOLD1',
    type: AssetType.GOLD,
    description: 'Gold asset',
    initialValue: 500000,
    initialQuantity: 0.5,
    currentValue: 450000,
    currentQuantity: 0.5,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    createdBy: 'user-1',
    updatedBy: 'user-1',
    portfolioId: 'portfolio-1',
    trades: [],
    portfolioAssets: [],
    getTotalValue: jest.fn().mockReturnValue(450000),
    getTotalQuantity: jest.fn().mockReturnValue(0.5),
    hasTrades: jest.fn().mockReturnValue(false),
    getDisplayName: jest.fn().mockReturnValue('Gold Asset (GOLD1)'),
    toJSON: jest.fn().mockReturnValue({}),
  };

  beforeEach(async () => {
    mockRepository = {
      create: jest.fn(),
      findAll: jest.fn(),
      findWithPagination: jest.fn(),
      findById: jest.fn(),
      findByIdWithPortfolio: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      findByUserId: jest.fn(),
      findByUserIdWithPagination: jest.fn(),
      findByType: jest.fn(),
      search: jest.fn(),
      countByUserId: jest.fn(),
      isNameUniqueGlobally: jest.fn(),
      isCodeUniqueGlobally: jest.fn(),
      hasTrades: jest.fn(),
      getAssetStatistics: jest.fn(),
      findByValueRange: jest.fn(),
      findRecent: jest.fn(),
      findByPortfolioId: jest.fn(),
      findByPortfolioIdWithPagination: jest.fn(),
      countByPortfolioId: jest.fn(),
      isNameUniqueInPortfolio: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AssetAnalyticsService,
        {
          provide: 'IAssetRepository',
          useValue: mockRepository,
        },
      ],
    }).compile();

    service = module.get<AssetAnalyticsService>(AssetAnalyticsService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('calculatePortfolioValue', () => {
    it('should calculate total portfolio value', async () => {
      const assets = [mockAsset1, mockAsset2, mockAsset3];
      mockRepository.findByPortfolioId.mockResolvedValue(assets);

      const result = await service.calculatePortfolioValue('portfolio-1');

      expect(mockRepository.findByPortfolioId).toHaveBeenCalledWith('portfolio-1');
      expect(result).toBe(3750000); // 1200000 + 2100000 + 450000
    });

    it('should return 0 for empty portfolio', async () => {
      mockRepository.findByPortfolioId.mockResolvedValue([]);

      const result = await service.calculatePortfolioValue('portfolio-1');

      expect(result).toBe(0);
    });
  });

  describe('calculateAssetAllocation', () => {
    it('should calculate asset allocation by type', async () => {
      const assets = [mockAsset1, mockAsset2, mockAsset3];
      mockRepository.findByPortfolioId.mockResolvedValue(assets);

      const result = await service.calculateAssetAllocation('portfolio-1');

      expect(result[AssetType.STOCK]).toBeCloseTo(32, 0); // 1200000 / 3750000 * 100
      expect(result[AssetType.BOND]).toBeCloseTo(56, 0); // 2100000 / 3750000 * 100
      expect(result[AssetType.GOLD]).toBeCloseTo(12, 0); // 450000 / 3750000 * 100
      expect(result[AssetType.DEPOSIT]).toBe(0);
      expect(result[AssetType.CASH]).toBe(0);
    });

    it('should return zero allocation for empty portfolio', async () => {
      mockRepository.findByPortfolioId.mockResolvedValue([]);

      const result = await service.calculateAssetAllocation('portfolio-1');

      expect(result[AssetType.STOCK]).toBe(0);
      expect(result[AssetType.BOND]).toBe(0);
      expect(result[AssetType.GOLD]).toBe(0);
      expect(result[AssetType.DEPOSIT]).toBe(0);
      expect(result[AssetType.CASH]).toBe(0);
    });
  });

  describe('calculatePerformanceMetrics', () => {
    it('should calculate performance metrics', async () => {
      const assets = [mockAsset1, mockAsset2, mockAsset3];
      mockRepository.findByPortfolioId.mockResolvedValue(assets);

      const result = await service.calculatePerformanceMetrics('portfolio-1');

      expect(result.totalReturn).toBe(250000); // (1200000-1000000) + (2100000-2000000) + (450000-500000)
      expect(result.averageReturn).toBeCloseTo(7.14, 1); // 250000 / 3500000 * 100
      expect(result.bestPerformer).toBe(mockAsset1); // 20% return
      expect(result.worstPerformer).toBe(mockAsset3); // -10% return
      expect(result.volatility).toBeGreaterThan(0);
    });

    it('should return zero metrics for empty portfolio', async () => {
      mockRepository.findByPortfolioId.mockResolvedValue([]);

      const result = await service.calculatePerformanceMetrics('portfolio-1');

      expect(result.totalReturn).toBe(0);
      expect(result.averageReturn).toBe(0);
      expect(result.bestPerformer).toBeNull();
      expect(result.worstPerformer).toBeNull();
      expect(result.volatility).toBe(0);
    });
  });

  describe('calculateRiskMetrics', () => {
    it('should calculate risk metrics', async () => {
      const assets = [mockAsset1, mockAsset2, mockAsset3];
      mockRepository.findByPortfolioId.mockResolvedValue(assets);

      const result = await service.calculateRiskMetrics('portfolio-1');

      expect(result.maxDrawdown).toBeGreaterThanOrEqual(0);
      expect(result.sharpeRatio).toBeDefined();
      expect(result.valueAtRisk).toBeGreaterThanOrEqual(0);
      expect(result.concentrationRisk).toBeGreaterThan(0);
    });

    it('should return zero risk metrics for empty portfolio', async () => {
      mockRepository.findByPortfolioId.mockResolvedValue([]);

      const result = await service.calculateRiskMetrics('portfolio-1');

      expect(result.maxDrawdown).toBe(0);
      expect(result.sharpeRatio).toBe(0);
      expect(result.valueAtRisk).toBe(0);
      expect(result.concentrationRisk).toBe(0);
    });
  });

  describe('generateAssetSummary', () => {
    it('should generate comprehensive asset summary', async () => {
      const assets = [mockAsset1, mockAsset2, mockAsset3];
      const statistics: AssetStatistics = {
        totalAssets: 3,
        assetsByType: {
          [AssetType.STOCK]: 1,
          [AssetType.BOND]: 1,
          [AssetType.GOLD]: 1,
          [AssetType.DEPOSIT]: 0,
          [AssetType.CASH]: 0,
        },
        totalValue: 3750000,
        averageValue: 1250000,
      };

      mockRepository.findByPortfolioId.mockResolvedValue(assets);
      mockRepository.getAssetStatistics.mockResolvedValue(statistics);
      mockRepository.findRecent.mockResolvedValue([mockAsset1]);

      const result = await service.generateAssetSummary('portfolio-1');

      expect(result.overview.totalAssets).toBe(3);
      expect(result.overview.totalValue).toBe(3750000);
      expect(result.overview.averageValue).toBe(1250000);
      expect(result.allocation).toBeDefined();
      expect(result.performance).toBeDefined();
      expect(result.risk).toBeDefined();
      expect(result.topAssets).toHaveLength(3);
      expect(result.recentActivity).toHaveLength(1);
    });
  });

  describe('calculateAssetCorrelation', () => {
    it('should calculate asset correlation matrix', async () => {
      const assets = [mockAsset1, mockAsset2];
      mockRepository.findByPortfolioId.mockResolvedValue(assets);

      const result = await service.calculateAssetCorrelation('portfolio-1');

      expect(result[mockAsset1.id]).toBeDefined();
      expect(result[mockAsset2.id]).toBeDefined();
      expect(result[mockAsset1.id][mockAsset1.id]).toBe(1);
      expect(result[mockAsset1.id][mockAsset2.id]).toBe(-0.2); // STOCK vs BOND correlation
    });

    it('should return empty matrix for less than 2 assets', async () => {
      mockRepository.findByPortfolioId.mockResolvedValue([mockAsset1]);

      const result = await service.calculateAssetCorrelation('portfolio-1');

      expect(result).toEqual({});
    });
  });

  describe('calculateDiversificationScore', () => {
    it('should calculate diversification score', async () => {
      const assets = [mockAsset1, mockAsset2, mockAsset3];
      mockRepository.findByPortfolioId.mockResolvedValue(assets);

      const result = await service.calculateDiversificationScore('portfolio-1');

      expect(result).toBeGreaterThanOrEqual(0);
      expect(result).toBeLessThanOrEqual(100);
    });
  });

  describe('getAssetPerformanceComparison', () => {
    it('should get asset performance comparison', async () => {
      const assets = [mockAsset1, mockAsset2, mockAsset3];
      mockRepository.findByPortfolioId.mockResolvedValue(assets);

      const result = await service.getAssetPerformanceComparison('portfolio-1', 'ALL');

      expect(result.period).toBe('ALL');
      expect(result.assets).toHaveLength(3);
      expect(result.assets[0].rank).toBe(1); // Best performer
      expect(result.assets[2].rank).toBe(3); // Worst performer
      expect(result.assets[0].return).toBeGreaterThan(result.assets[2].return);
    });

    it('should handle different time periods', async () => {
      const assets = [mockAsset1, mockAsset2];
      mockRepository.findByPortfolioId.mockResolvedValue(assets);

      const result = await service.getAssetPerformanceComparison('portfolio-1', '1M');

      expect(result.period).toBe('1M');
      expect(result.assets).toHaveLength(2);
    });
  });

  describe('calculateTypeCorrelation', () => {
    it('should calculate correlation between asset types', () => {
      const stockBondCorrelation = service['calculateTypeCorrelation'](AssetType.STOCK, AssetType.BOND);
      expect(stockBondCorrelation).toBe(-0.2);

      const stockStockCorrelation = service['calculateTypeCorrelation'](AssetType.STOCK, AssetType.STOCK);
      expect(stockStockCorrelation).toBe(0.8);

      const bondGoldCorrelation = service['calculateTypeCorrelation'](AssetType.BOND, AssetType.GOLD);
      expect(bondGoldCorrelation).toBe(0.3);
    });
  });
});
