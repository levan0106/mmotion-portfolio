import { Test, TestingModule } from '@nestjs/testing';
import { NotFoundException, BadRequestException, ConflictException } from '@nestjs/common';
import { AssetService, CreateAssetDto, UpdateAssetDto } from './asset.service';
import { IAssetRepository, AssetStatistics } from '../repositories/asset.repository.interface';
import { Asset } from '../entities/asset.entity';
import { AssetType } from '../enums/asset-type.enum';

describe('AssetService', () => {
  let service: AssetService;
  let mockRepository: jest.Mocked<IAssetRepository>;

  const mockAsset: Asset = {
    id: 'test-asset-id',
    name: 'Test Asset',
    code: 'TEST',
    type: AssetType.STOCK,
    description: 'Test asset description',
    initialValue: 1000000,
    initialQuantity: 100,
    currentValue: 1200000,
    currentQuantity: 100,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    createdBy: 'test-user-id',
    updatedBy: 'test-user-id',
    portfolioId: 'test-portfolio-id',
    trades: [],
    portfolioAssets: [],
    getTotalValue: jest.fn().mockReturnValue(1200000),
    getTotalQuantity: jest.fn().mockReturnValue(100),
    hasTrades: jest.fn().mockReturnValue(false),
    getDisplayName: jest.fn().mockReturnValue('Test Asset (TEST)'),
    toJSON: jest.fn().mockReturnValue({}),
  };

  beforeEach(async () => {
    mockRepository = {
      create: jest.fn(),
      findAll: jest.fn(),
      findWithPagination: jest.fn(),
      findById: jest.fn(),
      findByIdWithPortfolio: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      findByUserId: jest.fn(),
      findByUserIdWithPagination: jest.fn(),
      findByType: jest.fn(),
      search: jest.fn(),
      countByUserId: jest.fn(),
      isNameUniqueGlobally: jest.fn(),
      isCodeUniqueGlobally: jest.fn(),
      hasTrades: jest.fn(),
      getAssetStatistics: jest.fn(),
      findByValueRange: jest.fn(),
      findRecent: jest.fn(),
      findByPortfolioId: jest.fn(),
      findByPortfolioIdWithPagination: jest.fn(),
      countByPortfolioId: jest.fn(),
      isNameUniqueInPortfolio: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AssetService,
        {
          provide: 'IAssetRepository',
          useValue: mockRepository,
        },
      ],
    }).compile();

    service = module.get<AssetService>(AssetService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('create', () => {
  const createAssetDto: CreateAssetDto = {
    name: 'New Asset',
    code: 'NEW',
    type: AssetType.STOCK,
    description: 'New asset description',
    initialValue: 1000000,
    initialQuantity: 100,
    currentValue: 1200000,
    currentQuantity: 100,
    createdBy: 'test-user-id',
    updatedBy: 'test-user-id',
  };

    it('should create a new asset successfully', async () => {
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      mockRepository.isCodeUniqueGlobally.mockResolvedValue(true);
      mockRepository.create.mockResolvedValue(mockAsset);

      const result = await service.create(createAssetDto);

      expect(mockRepository.isNameUniqueGlobally).toHaveBeenCalledWith('New Asset');
      expect(mockRepository.isCodeUniqueGlobally).toHaveBeenCalledWith('NEW');
      expect(mockRepository.create).toHaveBeenCalledWith(createAssetDto);
      expect(result).toEqual(mockAsset);
    });

    it('should create asset without code', async () => {
      const dtoWithoutCode = { ...createAssetDto, code: undefined };
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      mockRepository.create.mockResolvedValue(mockAsset);

      const result = await service.create(dtoWithoutCode);

      expect(mockRepository.isNameUniqueGlobally).toHaveBeenCalled();
      expect(mockRepository.isCodeUniqueGlobally).not.toHaveBeenCalled();
      expect(result).toEqual(mockAsset);
    });

    it('should throw BadRequestException for empty name', async () => {
      const dtoWithEmptyName = { ...createAssetDto, name: '' };

      await expect(service.create(dtoWithEmptyName)).rejects.toThrow(
        new BadRequestException('Asset name is required')
      );
    });

    it('should throw BadRequestException for negative initial value', async () => {
      const dtoWithNegativeValue = { ...createAssetDto, initialValue: -1000 };

      await expect(service.create(dtoWithNegativeValue)).rejects.toThrow(
        new BadRequestException('Initial value must be non-negative')
      );
    });

    it('should throw BadRequestException for zero initial quantity', async () => {
      const dtoWithZeroQuantity = { ...createAssetDto, initialQuantity: 0 };

      await expect(service.create(dtoWithZeroQuantity)).rejects.toThrow(
        new BadRequestException('Initial quantity must be positive')
      );
    });

    it('should throw ConflictException for duplicate name', async () => {
      mockRepository.isNameUniqueGlobally.mockResolvedValue(false);

      await expect(service.create(createAssetDto)).rejects.toThrow(
        new ConflictException('Asset name must be globally unique')
      );
    });

    it('should throw ConflictException for duplicate code', async () => {
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      mockRepository.isCodeUniqueGlobally.mockResolvedValue(false);

      await expect(service.create(createAssetDto)).rejects.toThrow(
        new ConflictException('Asset code must be globally unique')
      );
    });
  });

  describe('findAll', () => {
    it('should return paginated assets', async () => {
      const expectedResult = {
        data: [mockAsset],
        total: 1,
        page: 1,
        limit: 10,
      };

      mockRepository.findWithPagination.mockResolvedValue(expectedResult);

      const result = await service.findAll();

      expect(mockRepository.findWithPagination).toHaveBeenCalledWith({});
      expect(result).toEqual(expectedResult);
    });

    it('should pass filters to repository', async () => {
      const filters = { portfolioId: 'test-portfolio-id', type: AssetType.STOCK };
      const expectedResult = {
        data: [mockAsset],
        total: 1,
        page: 1,
        limit: 10,
      };

      mockRepository.findWithPagination.mockResolvedValue(expectedResult);

      const result = await service.findAll(filters);

      expect(mockRepository.findWithPagination).toHaveBeenCalledWith(filters);
      expect(result).toEqual(expectedResult);
    });
  });

  describe('findById', () => {
    it('should return asset when found', async () => {
      mockRepository.findById.mockResolvedValue(mockAsset);

      const result = await service.findById('test-asset-id');

      expect(mockRepository.findById).toHaveBeenCalledWith('test-asset-id');
      expect(result).toEqual(mockAsset);
    });

    it('should throw NotFoundException when asset not found', async () => {
      mockRepository.findById.mockResolvedValue(null);

      await expect(service.findById('non-existent-id')).rejects.toThrow(
        new NotFoundException('Asset with ID non-existent-id not found')
      );
    });
  });

  describe('update', () => {
    const updateAssetDto: UpdateAssetDto = {
      name: 'Updated Asset',
      updatedBy: 'test-user-id',
    };

    it('should update asset successfully', async () => {
      mockRepository.findById.mockResolvedValue(mockAsset);
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      const updatedAsset = { ...mockAsset, name: 'Updated Asset' };
      mockRepository.update.mockResolvedValue(updatedAsset as Asset);

      const result = await service.update('test-asset-id', updateAssetDto);

      expect(mockRepository.findById).toHaveBeenCalledWith('test-asset-id');
      expect(mockRepository.isNameUniqueGlobally).toHaveBeenCalledWith(
        'Updated Asset',
        'test-asset-id'
      );
      expect(mockRepository.update).toHaveBeenCalledWith('test-asset-id', updateAssetDto);
      expect(result.name).toBe('Updated Asset');
    });

    it('should throw NotFoundException when asset not found', async () => {
      mockRepository.findById.mockResolvedValue(null);

      await expect(service.update('non-existent-id', updateAssetDto)).rejects.toThrow(
        new NotFoundException('Asset with ID non-existent-id not found')
      );
    });

    it('should throw ConflictException for duplicate name', async () => {
      mockRepository.findById.mockResolvedValue(mockAsset);
      mockRepository.isNameUniqueGlobally.mockResolvedValue(false);

      await expect(service.update('test-asset-id', updateAssetDto)).rejects.toThrow(
        new ConflictException('Asset name must be globally unique')
      );
    });

    it('should throw BadRequestException for empty name', async () => {
      const dtoWithEmptyName = { ...updateAssetDto, name: '' };
      mockRepository.findById.mockResolvedValue(mockAsset);

      await expect(service.update('test-asset-id', dtoWithEmptyName)).rejects.toThrow(
        new BadRequestException('Asset name cannot be empty')
      );
    });
  });

  describe('delete', () => {
    it('should delete asset successfully', async () => {
      mockRepository.findById.mockResolvedValue(mockAsset);
      mockRepository.hasTrades.mockResolvedValue(false);
      mockRepository.delete.mockResolvedValue(undefined);

      await service.delete('test-asset-id');

      expect(mockRepository.findById).toHaveBeenCalledWith('test-asset-id');
      expect(mockRepository.hasTrades).toHaveBeenCalledWith('test-asset-id');
      expect(mockRepository.delete).toHaveBeenCalledWith('test-asset-id');
    });

    it('should throw NotFoundException when asset not found', async () => {
      mockRepository.findById.mockResolvedValue(null);

      await expect(service.delete('non-existent-id')).rejects.toThrow(
        new NotFoundException('Asset with ID non-existent-id not found')
      );
    });

    it('should throw BadRequestException when asset has trades', async () => {
      mockRepository.findById.mockResolvedValue(mockAsset);
      mockRepository.hasTrades.mockResolvedValue(true);

      await expect(service.delete('test-asset-id')).rejects.toThrow(
        new BadRequestException('Cannot delete asset with associated trades')
      );
    });
  });

  describe('findByUserId', () => {
    it('should return paginated assets for user', async () => {
      const expectedResult = {
        data: [mockAsset],
        total: 1,
        page: 1,
        limit: 10,
      };

      mockRepository.findByUserIdWithPagination.mockResolvedValue(expectedResult);

      const result = await service.findByUserId('test-user-id');

      expect(mockRepository.findByUserIdWithPagination).toHaveBeenCalledWith(
        'test-user-id',
        {}
      );
      expect(result).toEqual(expectedResult);
    });
  });

  describe('findByType', () => {
    it('should return assets by type', async () => {
      const expectedAssets = [mockAsset];
      mockRepository.findByType.mockResolvedValue(expectedAssets);

      const result = await service.findByType(AssetType.STOCK);

      expect(mockRepository.findByType).toHaveBeenCalledWith(AssetType.STOCK, undefined);
      expect(result).toEqual(expectedAssets);
    });

    it('should return assets by type and user', async () => {
      const expectedAssets = [mockAsset];
      mockRepository.findByType.mockResolvedValue(expectedAssets);

      const result = await service.findByType(AssetType.STOCK, 'test-user-id');

      expect(mockRepository.findByType).toHaveBeenCalledWith(AssetType.STOCK, 'test-user-id');
      expect(result).toEqual(expectedAssets);
    });
  });

  describe('search', () => {
    it('should search assets successfully', async () => {
      const expectedAssets = [mockAsset];
      mockRepository.search.mockResolvedValue(expectedAssets);

      const result = await service.search('test');

      expect(mockRepository.search).toHaveBeenCalledWith('test', undefined);
      expect(result).toEqual(expectedAssets);
    });

    it('should throw BadRequestException for short search term', async () => {
      await expect(service.search('a')).rejects.toThrow(
        new BadRequestException('Search term must be at least 2 characters long')
      );
    });

    it('should throw BadRequestException for empty search term', async () => {
      await expect(service.search('')).rejects.toThrow(
        new BadRequestException('Search term must be at least 2 characters long')
      );
    });
  });

  describe('getAssetStatistics', () => {
    it('should return asset statistics', async () => {
      const expectedStats: AssetStatistics = {
        totalAssets: 5,
        assetsByType: {
          [AssetType.STOCK]: 3,
          [AssetType.BOND]: 2,
          [AssetType.GOLD]: 0,
          [AssetType.DEPOSIT]: 0,
          [AssetType.CASH]: 0,
        },
        totalValue: 10000,
        averageValue: 2000,
      };

      mockRepository.getAssetStatistics.mockResolvedValue(expectedStats);

      const result = await service.getAssetStatistics('test-user-id');

      expect(mockRepository.getAssetStatistics).toHaveBeenCalledWith('test-user-id');
      expect(result).toEqual(expectedStats);
    });
  });

  describe('findByValueRange', () => {
    it('should return assets in value range', async () => {
      const expectedAssets = [mockAsset];
      mockRepository.findByValueRange.mockResolvedValue(expectedAssets);

      const result = await service.findByValueRange(1000, 2000);

      expect(mockRepository.findByValueRange).toHaveBeenCalledWith(1000, 2000, undefined);
      expect(result).toEqual(expectedAssets);
    });

    it('should throw BadRequestException for negative values', async () => {
      await expect(service.findByValueRange(-1000, 2000)).rejects.toThrow(
        new BadRequestException('Value range must be positive')
      );
    });

    it('should throw BadRequestException when min > max', async () => {
      await expect(service.findByValueRange(2000, 1000)).rejects.toThrow(
        new BadRequestException('Minimum value cannot be greater than maximum value')
      );
    });
  });

  describe('findRecent', () => {
    it('should return recent assets', async () => {
      const expectedAssets = [mockAsset];
      mockRepository.findRecent.mockResolvedValue(expectedAssets);

      const result = await service.findRecent(5);

      expect(mockRepository.findRecent).toHaveBeenCalledWith(5, undefined);
      expect(result).toEqual(expectedAssets);
    });

    it('should throw BadRequestException for invalid limit', async () => {
      await expect(service.findRecent(0)).rejects.toThrow(
        new BadRequestException('Limit must be between 1 and 100')
      );
    });

    it('should throw BadRequestException for limit > 100', async () => {
      await expect(service.findRecent(101)).rejects.toThrow(
        new BadRequestException('Limit must be between 1 and 100')
      );
    });
  });

  describe('exists', () => {
    it('should return true when asset exists', async () => {
      mockRepository.findById.mockResolvedValue(mockAsset);

      const result = await service.exists('test-asset-id');

      expect(result).toBe(true);
    });

    it('should return false when asset does not exist', async () => {
      mockRepository.findById.mockResolvedValue(null);

      const result = await service.exists('non-existent-id');

      expect(result).toBe(false);
    });
  });

  describe('getAssetCount', () => {
    it('should return asset count', async () => {
      mockRepository.countByUserId.mockResolvedValue(5);

      const result = await service.getAssetCount('test-user-id');

      expect(mockRepository.countByUserId).toHaveBeenCalledWith('test-user-id');
      expect(result).toBe(5);
    });
  });

  describe('hasTrades', () => {
    it('should return true when asset has trades', async () => {
      mockRepository.hasTrades.mockResolvedValue(true);

      const result = await service.hasTrades('test-asset-id');

      expect(mockRepository.hasTrades).toHaveBeenCalledWith('test-asset-id');
      expect(result).toBe(true);
    });

    it('should return false when asset has no trades', async () => {
      mockRepository.hasTrades.mockResolvedValue(false);

      const result = await service.hasTrades('test-asset-id');

      expect(result).toBe(false);
    });
  });

  describe('getAssetSummary', () => {
    it('should return asset summary', async () => {
      const statistics: AssetStatistics = {
        totalAssets: 5,
        assetsByType: {
          [AssetType.STOCK]: 3,
          [AssetType.BOND]: 2,
          [AssetType.GOLD]: 0,
          [AssetType.DEPOSIT]: 0,
          [AssetType.CASH]: 0,
        },
        totalValue: 10000,
        averageValue: 2000,
      };

      const recentAssets = [mockAsset];

      mockRepository.getAssetStatistics.mockResolvedValue(statistics);
      mockRepository.findRecent.mockResolvedValue(recentAssets);

      const result = await service.getAssetSummary('test-portfolio-id');

      expect(result).toEqual({
        totalAssets: 5,
        totalValue: 10000,
        averageValue: 2000,
        assetsByType: {
          [AssetType.STOCK]: 3,
          [AssetType.BOND]: 2,
          [AssetType.GOLD]: 0,
          [AssetType.DEPOSIT]: 0,
          [AssetType.CASH]: 0,
        },
        recentAssets,
      });
    });
  });
});
