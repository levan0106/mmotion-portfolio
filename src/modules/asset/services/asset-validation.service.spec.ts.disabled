import { Test, TestingModule } from '@nestjs/testing';
import { BadRequestException, ConflictException } from '@nestjs/common';
import { AssetValidationService } from './asset-validation.service';
import { IAssetRepository } from '../repositories/asset.repository.interface';
import { Asset } from '../entities/asset.entity';
import { AssetType } from '../enums/asset-type.enum';
import { CreateAssetDto, UpdateAssetDto } from './asset.service';

describe('AssetValidationService', () => {
  let service: AssetValidationService;
  let mockRepository: jest.Mocked<IAssetRepository>;

  const mockAsset: Asset = {
    id: 'test-asset-id',
    name: 'Test Asset',
    code: 'TEST',
    type: AssetType.STOCK,
    description: 'Test asset description',
    initialValue: 1000000,
    initialQuantity: 100,
    currentValue: 1200000,
    currentQuantity: 100,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    createdBy: 'test-user-id',
    updatedBy: 'test-user-id',
    portfolioId: 'test-portfolio-id',
    trades: [],
    portfolioAssets: [],
    getTotalValue: jest.fn().mockReturnValue(1200000),
    getTotalQuantity: jest.fn().mockReturnValue(100),
    hasTrades: jest.fn().mockReturnValue(false),
    getDisplayName: jest.fn().mockReturnValue('Test Asset (TEST)'),
    toJSON: jest.fn().mockReturnValue({}),
  };

  const validCreateAssetDto: CreateAssetDto = {
    name: 'New Asset',
    code: 'NEW',
    type: AssetType.STOCK,
    description: 'New asset description',
    initialValue: 1000000,
    initialQuantity: 100,
    currentValue: 1200000,
    currentQuantity: 100,
    createdBy: 'test-user-id',
    updatedBy: 'test-user-id',
  };

  beforeEach(async () => {
    mockRepository = {
      create: jest.fn(),
      findAll: jest.fn(),
      findWithPagination: jest.fn(),
      findById: jest.fn(),
      findByIdWithPortfolio: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      findByUserId: jest.fn(),
      findByUserIdWithPagination: jest.fn(),
      findByType: jest.fn(),
      search: jest.fn(),
      countByUserId: jest.fn(),
      isNameUniqueGlobally: jest.fn(),
      isCodeUniqueGlobally: jest.fn(),
      hasTrades: jest.fn(),
      getAssetStatistics: jest.fn(),
      findByValueRange: jest.fn(),
      findRecent: jest.fn(),
      findByPortfolioId: jest.fn(),
      findByPortfolioIdWithPagination: jest.fn(),
      countByPortfolioId: jest.fn(),
      isNameUniqueInPortfolio: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AssetValidationService,
        {
          provide: 'IAssetRepository',
          useValue: mockRepository,
        },
      ],
    }).compile();

    service = module.get<AssetValidationService>(AssetValidationService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('validateAssetCreation', () => {
    it('should validate successfully for valid asset data', async () => {
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      mockRepository.isCodeUniqueGlobally.mockResolvedValue(true);

      await expect(service.validateAssetCreation(validCreateAssetDto)).resolves.not.toThrow();
    });


    it('should throw BadRequestException for missing name', async () => {
      const dto = { ...validCreateAssetDto, name: '' };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Asset name is required')
      );
    });

    it('should throw BadRequestException for missing type', async () => {
      const dto = { ...validCreateAssetDto, type: undefined as any };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Asset type is required')
      );
    });

    it('should throw BadRequestException for negative initial value', async () => {
      const dto = { ...validCreateAssetDto, initialValue: -1000 };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Initial value must be non-negative')
      );
    });

    it('should throw BadRequestException for zero initial quantity', async () => {
      const dto = { ...validCreateAssetDto, initialQuantity: 0 };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Initial quantity must be positive')
      );
    });

    it('should throw BadRequestException for name too long', async () => {
      const dto = { ...validCreateAssetDto, name: 'a'.repeat(256) };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Asset name cannot exceed 255 characters')
      );
    });

    it('should throw BadRequestException for code too long', async () => {
      const dto = { ...validCreateAssetDto, code: 'a'.repeat(51) };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Asset code cannot exceed 50 characters')
      );
    });

    it('should throw BadRequestException for invalid asset type', async () => {
      const dto = { ...validCreateAssetDto, type: 'INVALID' as any };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Invalid asset type')
      );
    });

    it('should throw ConflictException for duplicate name', async () => {
      mockRepository.isNameUniqueGlobally.mockResolvedValue(false);

      await expect(service.validateAssetCreation(validCreateAssetDto)).rejects.toThrow(
        new ConflictException('Asset name must be globally unique')
      );
    });

    it('should throw ConflictException for duplicate code', async () => {
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      mockRepository.isCodeUniqueGlobally.mockResolvedValue(false);

      await expect(service.validateAssetCreation(validCreateAssetDto)).rejects.toThrow(
        new ConflictException('Asset code must be globally unique')
      );
    });

    it('should validate asset type specific rules for STOCK', async () => {
      const dto = { ...validCreateAssetDto, type: AssetType.STOCK, initialValue: 500 };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Stock value should be at least 1,000 VND')
      );
    });

    it('should validate asset type specific rules for BOND', async () => {
      const dto = { ...validCreateAssetDto, type: AssetType.BOND, initialValue: 50000 };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Bond value should be at least 100,000 VND')
      );
    });

    it('should validate asset type specific rules for GOLD', async () => {
      const dto = { ...validCreateAssetDto, type: AssetType.GOLD, initialQuantity: 0.0001 };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Gold quantity should be at least 0.001')
      );
    });

    it('should validate asset type specific rules for DEPOSIT', async () => {
      const dto = { ...validCreateAssetDto, type: AssetType.DEPOSIT, initialValue: 500000 };

      await expect(service.validateAssetCreation(dto)).rejects.toThrow(
        new BadRequestException('Deposit value should be at least 1,000,000 VND')
      );
    });
  });

  describe('validateAssetUpdate', () => {
    const updateAssetDto: UpdateAssetDto = {
      name: 'Updated Asset',
      updatedBy: 'test-user-id',
    };

    it('should validate successfully for valid update data', async () => {
      mockRepository.findById.mockResolvedValue(mockAsset);
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);

      await expect(service.validateAssetUpdate('test-asset-id', updateAssetDto)).resolves.not.toThrow();
    });

    it('should throw BadRequestException for empty name', async () => {
      const dto = { ...updateAssetDto, name: '' };
      mockRepository.findById.mockResolvedValue(mockAsset);

      await expect(service.validateAssetUpdate('test-asset-id', dto)).rejects.toThrow(
        new BadRequestException('Asset name cannot be empty')
      );
    });

    it('should throw BadRequestException for name too long', async () => {
      const dto = { ...updateAssetDto, name: 'a'.repeat(256) };
      mockRepository.findById.mockResolvedValue(mockAsset);

      await expect(service.validateAssetUpdate('test-asset-id', dto)).rejects.toThrow(
        new BadRequestException('Asset name cannot exceed 255 characters')
      );
    });

    it('should throw BadRequestException for negative current value', async () => {
      const dto = { ...updateAssetDto, currentValue: -1000 };
      mockRepository.findById.mockResolvedValue(mockAsset);

      await expect(service.validateAssetUpdate('test-asset-id', dto)).rejects.toThrow(
        new BadRequestException('Current value must be non-negative')
      );
    });

    it('should throw ConflictException for duplicate name', async () => {
      mockRepository.findById.mockResolvedValue(mockAsset);
      mockRepository.isNameUniqueGlobally.mockResolvedValue(false);

      await expect(service.validateAssetUpdate('test-asset-id', updateAssetDto)).rejects.toThrow(
        new ConflictException('Asset name must be globally unique')
      );
    });
  });

  describe('validateAssetDeletion', () => {
    it('should validate successfully when asset has no trades', async () => {
      mockRepository.hasTrades.mockResolvedValue(false);

      await expect(service.validateAssetDeletion('test-asset-id')).resolves.not.toThrow();
    });

    it('should throw BadRequestException when asset has trades', async () => {
      mockRepository.hasTrades.mockResolvedValue(true);

      await expect(service.validateAssetDeletion('test-asset-id')).rejects.toThrow(
        new BadRequestException('Cannot delete asset with associated trades')
      );
    });
  });

  describe('validateBulkAssetCreation', () => {
    it('should validate successfully for valid asset list', async () => {
      const assets = [validCreateAssetDto, { ...validCreateAssetDto, name: 'Another Asset', code: 'ANOTHER' }];
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      mockRepository.isCodeUniqueGlobally.mockResolvedValue(true);

      await expect(service.validateBulkAssetCreation(assets)).resolves.not.toThrow();
    });

    it('should throw BadRequestException for empty asset list', async () => {
      await expect(service.validateBulkAssetCreation([])).rejects.toThrow(
        new BadRequestException('Asset list cannot be empty')
      );
    });

    it('should throw BadRequestException for too many assets', async () => {
      const assets = Array(101).fill(validCreateAssetDto);

      await expect(service.validateBulkAssetCreation(assets)).rejects.toThrow(
        new BadRequestException('Cannot create more than 100 assets at once')
      );
    });

    it('should throw BadRequestException for duplicate names in batch', async () => {
      const assets = [validCreateAssetDto, { ...validCreateAssetDto, code: 'ANOTHER' }];
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      mockRepository.isCodeUniqueGlobally.mockResolvedValue(true);

      await expect(service.validateBulkAssetCreation(assets)).rejects.toThrow(
        new BadRequestException('Asset names must be unique within the batch')
      );
    });

    it('should throw BadRequestException for duplicate codes in batch', async () => {
      const assets = [
        validCreateAssetDto,
        { ...validCreateAssetDto, name: 'Another Asset', code: 'NEW' },
        { ...validCreateAssetDto, name: 'Third Asset', code: 'NEW' }
      ];
      mockRepository.isNameUniqueGlobally.mockResolvedValue(true);
      mockRepository.isCodeUniqueGlobally.mockResolvedValue(true);

      await expect(service.validateBulkAssetCreation(assets)).rejects.toThrow(
        new BadRequestException('Asset codes must be unique within the batch')
      );
    });
  });

  describe('validateSearchParameters', () => {
    it('should validate successfully for valid search parameters', () => {
      expect(() => service.validateSearchParameters('test', 'portfolio-id')).not.toThrow();
    });

    it('should throw BadRequestException for short search term', () => {
      expect(() => service.validateSearchParameters('a')).toThrow(
        new BadRequestException('Search term must be at least 2 characters long')
      );
    });

    it('should throw BadRequestException for empty search term', () => {
      expect(() => service.validateSearchParameters('')).toThrow(
        new BadRequestException('Search term must be at least 2 characters long')
      );
    });

    it('should throw BadRequestException for long search term', () => {
      expect(() => service.validateSearchParameters('a'.repeat(101))).toThrow(
        new BadRequestException('Search term cannot exceed 100 characters')
      );
    });

    it('should throw BadRequestException for empty portfolio ID', () => {
      expect(() => service.validateSearchParameters('test', '   ')).toThrow(
        new BadRequestException('Portfolio ID cannot be empty')
      );
    });
  });

  describe('validatePaginationParameters', () => {
    it('should validate successfully for valid pagination parameters', () => {
      expect(() => service.validatePaginationParameters(10, 0)).not.toThrow();
    });

    it('should throw BadRequestException for limit too small', () => {
      expect(() => service.validatePaginationParameters(0)).toThrow(
        new BadRequestException('Limit must be between 1 and 100')
      );
    });

    it('should throw BadRequestException for limit too large', () => {
      expect(() => service.validatePaginationParameters(101)).toThrow(
        new BadRequestException('Limit must be between 1 and 100')
      );
    });

    it('should throw BadRequestException for negative offset', () => {
      expect(() => service.validatePaginationParameters(10, -1)).toThrow(
        new BadRequestException('Offset must be non-negative')
      );
    });
  });

  describe('validateValueConsistency', () => {
    it('should validate successfully for consistent values', () => {
      const assetData = {
        initialValue: 1000000,
        currentValue: 1200000,
        initialQuantity: 100,
        currentQuantity: 100,
      };

      expect(() => service['validateValueConsistency'](assetData)).not.toThrow();
    });

    it('should throw BadRequestException for negative current values', () => {
      const assetData = {
        currentValue: -1000,
        currentQuantity: -10,
      };

      expect(() => service['validateValueConsistency'](assetData)).toThrow(
        new BadRequestException('Current value and quantity must be non-negative')
      );
    });

    it('should throw BadRequestException for excessive value change', () => {
      const assetData = {
        initialValue: 1000000,
        currentValue: 12000000, // 1200% increase
      };

      expect(() => service['validateValueConsistency'](assetData)).toThrow(
        new BadRequestException('Current value change is too significant (>1000%)')
      );
    });
  });
});
