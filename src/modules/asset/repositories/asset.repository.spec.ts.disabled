import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository, SelectQueryBuilder } from 'typeorm';
import { AssetRepository, AssetFilters, PaginatedResponse } from './asset.repository';
import { Asset } from '../entities/asset.entity';
import { AssetType } from '../enums/asset-type.enum';

describe('AssetRepository', () => {
  let repository: AssetRepository;
  let mockRepository: jest.Mocked<Repository<Asset>>;
  let mockQueryBuilder: jest.Mocked<SelectQueryBuilder<Asset>>;

  const mockAsset: Asset = {
    id: 'test-asset-id',
    name: 'Test Asset',
    code: 'TEST',
    type: AssetType.STOCK,
    description: 'Test asset description',
    initialValue: 1000000,
    initialQuantity: 100,
    currentValue: 1200000,
    currentQuantity: 100,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    createdBy: 'test-user-id',
    updatedBy: 'test-user-id',
    portfolioId: 'test-portfolio-id',
    trades: [],
    portfolioAssets: [],
    getTotalValue: jest.fn().mockReturnValue(1200000),
    getTotalQuantity: jest.fn().mockReturnValue(100),
    hasTrades: jest.fn().mockReturnValue(false),
    getDisplayName: jest.fn().mockReturnValue('Test Asset (TEST)'),
    toJSON: jest.fn().mockReturnValue({}),
  };

  beforeEach(async () => {
    mockQueryBuilder = {
      getManyAndCount: jest.fn(),
      getMany: jest.fn(),
      getCount: jest.fn(),
      getOne: jest.fn(),
      where: jest.fn().mockReturnThis(),
      andWhere: jest.fn().mockReturnThis(),
      leftJoin: jest.fn().mockReturnThis(),
      leftJoinAndSelect: jest.fn().mockReturnThis(),
      orderBy: jest.fn().mockReturnThis(),
      limit: jest.fn().mockReturnThis(),
      offset: jest.fn().mockReturnThis(),
    } as any;

    mockRepository = {
      create: jest.fn(),
      save: jest.fn(),
      find: jest.fn(),
      findOne: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
      createQueryBuilder: jest.fn().mockReturnValue(mockQueryBuilder),
    } as any;

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AssetRepository,
        {
          provide: getRepositoryToken(Asset),
          useValue: mockRepository,
        },
      ],
    }).compile();

    repository = module.get<AssetRepository>(AssetRepository);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('create', () => {
    it('should create a new asset', async () => {
      const assetData = { name: 'New Asset', type: AssetType.STOCK };
      const createdAsset = { ...mockAsset, ...assetData };

      mockRepository.create.mockReturnValue(createdAsset as Asset);
      mockRepository.save.mockResolvedValue(createdAsset as Asset);

      const result = await repository.create(assetData);

      expect(mockRepository.create).toHaveBeenCalledWith(assetData);
      expect(mockRepository.save).toHaveBeenCalledWith(createdAsset);
      expect(result).toEqual(createdAsset);
    });
  });

  describe('findAll', () => {
    it('should find all assets with default filters', async () => {
      const assets = [mockAsset];
      const total = 1;

      mockQueryBuilder.getManyAndCount.mockResolvedValue([assets, total]);

      const result = await repository.findAll();

      expect(mockRepository.createQueryBuilder).toHaveBeenCalledWith('asset');
      expect(mockQueryBuilder.leftJoinAndSelect).toHaveBeenCalledWith('asset.trades', 'trades');
      expect(mockQueryBuilder.orderBy).toHaveBeenCalledWith('asset.createdAt', 'DESC');
      expect(result).toEqual([assets, total]);
    });

    it('should find assets with filters', async () => {
      const filters: AssetFilters = {
        createdBy: 'test-user-id',
        type: AssetType.STOCK,
        search: 'test',
        sortBy: 'name',
        sortOrder: 'ASC',
        limit: 10,
        offset: 0,
      };

      const assets = [mockAsset];
      const total = 1;

      mockQueryBuilder.getManyAndCount.mockResolvedValue([assets, total]);

      const result = await repository.findAll(filters);

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(
        'asset.createdBy = :createdBy',
        { createdBy: 'test-user-id' }
      );
      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(
        'asset.type = :type',
        { type: AssetType.STOCK }
      );
      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(
        '(asset.name ILIKE :search OR asset.code ILIKE :search OR asset.description ILIKE :search)',
        { search: '%test%' }
      );
      expect(mockQueryBuilder.orderBy).toHaveBeenCalledWith('asset.name', 'ASC');
      expect(mockQueryBuilder.limit).toHaveBeenCalledWith(10);
      // Offset is only called when > 0, so we don't expect it to be called with 0
      expect(result).toEqual([assets, total]);
    });
  });

  describe('findWithPagination', () => {
    it('should return paginated response', async () => {
      const filters: AssetFilters = {
        limit: 10,
        offset: 0,
      };

      const assets = [mockAsset];
      const total = 1;

      mockQueryBuilder.getManyAndCount.mockResolvedValue([assets, total]);

      const result = await repository.findWithPagination(filters);

      expect(result).toEqual({
        data: assets,
        total,
        page: 1,
        limit: 10,
      });
    });
  });

  describe('findById', () => {
    it('should find asset by ID', async () => {
      mockRepository.findOne.mockResolvedValue(mockAsset);

      const result = await repository.findById('test-asset-id');

      expect(mockRepository.findOne).toHaveBeenCalledWith({
        where: { id: 'test-asset-id' },
        relations: ['portfolio', 'trades', 'portfolioAssets'],
      });
      expect(result).toEqual(mockAsset);
    });

    it('should return null if asset not found', async () => {
      mockRepository.findOne.mockResolvedValue(null);

      const result = await repository.findById('non-existent-id');

      expect(result).toBeNull();
    });
  });

  describe('findByIdWithPortfolio', () => {
    it('should find asset by ID with portfolio relationship', async () => {
      mockRepository.findOne.mockResolvedValue(mockAsset);

      const result = await repository.findByIdWithPortfolio('test-asset-id');

      expect(mockRepository.findOne).toHaveBeenCalledWith({
        where: { id: 'test-asset-id' },
        relations: ['portfolio'],
      });
      expect(result).toEqual(mockAsset);
    });
  });

  describe('update', () => {
    it('should update asset and return updated asset', async () => {
      const updateData = { name: 'Updated Asset' };
      const updatedAsset = { ...mockAsset, ...updateData };

      mockRepository.update.mockResolvedValue({ affected: 1 } as any);
      mockRepository.findOne.mockResolvedValue(updatedAsset as Asset);

      const result = await repository.update('test-asset-id', updateData);

      expect(mockRepository.update).toHaveBeenCalledWith('test-asset-id', updateData);
      expect(mockRepository.findOne).toHaveBeenCalledWith({
        where: { id: 'test-asset-id' },
        relations: ['portfolio', 'trades', 'portfolioAssets'],
      });
      expect(result).toEqual(updatedAsset);
    });
  });

  describe('delete', () => {
    it('should delete asset by ID', async () => {
      mockRepository.delete.mockResolvedValue({ affected: 1 } as any);

      await repository.delete('test-asset-id');

      expect(mockRepository.delete).toHaveBeenCalledWith('test-asset-id');
    });
  });

  describe('findByPortfolioId', () => {
    it('should find assets by portfolio ID', async () => {
      const assets = [mockAsset];
      mockRepository.find.mockResolvedValue(assets);

      const result = await repository.findByPortfolioId('test-portfolio-id');

      expect(mockRepository.find).toHaveBeenCalledWith({
        where: { portfolioId: 'test-portfolio-id' },
        relations: ['trades'],
        order: { createdAt: 'DESC' },
      });
      expect(result).toEqual(assets);
    });
  });

  describe('findByType', () => {
    it('should find assets by type', async () => {
      const assets = [mockAsset];
      mockRepository.find.mockResolvedValue(assets);

      const result = await repository.findByType(AssetType.STOCK);

      expect(mockRepository.find).toHaveBeenCalledWith({
        where: { type: AssetType.STOCK },
        order: { createdAt: 'DESC' },
      });
      expect(result).toEqual(assets);
    });

    it('should find assets by type and user ID', async () => {
      const assets = [mockAsset];
      mockRepository.find.mockResolvedValue(assets);

      const result = await repository.findByType(AssetType.STOCK, 'test-user-id');

      expect(mockRepository.find).toHaveBeenCalledWith({
        where: { type: AssetType.STOCK, createdBy: 'test-user-id' },
        order: { createdAt: 'DESC' },
      });
      expect(result).toEqual(assets);
    });
  });

  describe('search', () => {
    it('should search assets by term', async () => {
      const assets = [mockAsset];
      mockQueryBuilder.getMany.mockResolvedValue(assets);

      const result = await repository.search('test');

      expect(mockRepository.createQueryBuilder).toHaveBeenCalledWith('asset');
      expect(mockQueryBuilder.where).toHaveBeenCalledWith(
        '(asset.name ILIKE :search OR asset.code ILIKE :search OR asset.description ILIKE :search)',
        { search: '%test%' }
      );
      expect(mockQueryBuilder.orderBy).toHaveBeenCalledWith('asset.createdAt', 'DESC');
      expect(result).toEqual(assets);
    });

    it('should search assets by term with user filter', async () => {
      const assets = [mockAsset];
      mockQueryBuilder.getMany.mockResolvedValue(assets);

      const result = await repository.search('test', 'test-user-id');

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(
        'asset.createdBy = :userId',
        { userId: 'test-user-id' }
      );
      expect(result).toEqual(assets);
    });
  });

  describe('countByPortfolioId', () => {
    it('should count assets by portfolio ID', async () => {
      mockRepository.count.mockResolvedValue(5);

      const result = await repository.countByPortfolioId('test-portfolio-id');

      expect(mockRepository.count).toHaveBeenCalledWith({
        where: { portfolioId: 'test-portfolio-id' },
      });
      expect(result).toBe(5);
    });
  });

  describe('isNameUniqueInPortfolio', () => {
    it('should return true if name is unique', async () => {
      mockQueryBuilder.getCount.mockResolvedValue(0);

      const result = await repository.isNameUniqueInPortfolio(
        'test-portfolio-id',
        'Unique Name'
      );

      expect(mockQueryBuilder.where).toHaveBeenCalledWith(
        'LOWER(asset.name) = LOWER(:name)',
        { name: 'test-portfolio-id' }
      );
      expect(result).toBe(true);
    });

    it('should return false if name is not unique', async () => {
      mockQueryBuilder.getCount.mockResolvedValue(1);

      const result = await repository.isNameUniqueInPortfolio(
        'test-portfolio-id',
        'Existing Name'
      );

      expect(result).toBe(false);
    });

    it('should exclude specified ID from uniqueness check', async () => {
      mockQueryBuilder.getCount.mockResolvedValue(0);

      const result = await repository.isNameUniqueInPortfolio(
        'test-portfolio-id',
        'Test Name',
        'exclude-id'
      );

      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith(
        'asset.id != :excludeId',
        { excludeId: 'exclude-id' }
      );
      expect(result).toBe(true);
    });
  });

  describe('isCodeUniqueGlobally', () => {
    it('should return true if code is unique', async () => {
      mockQueryBuilder.getCount.mockResolvedValue(0);

      const result = await repository.isCodeUniqueGlobally('UNIQUE');

      expect(mockQueryBuilder.where).toHaveBeenCalledWith(
        'asset.code = :code',
        { code: 'UNIQUE' }
      );
      expect(result).toBe(true);
    });

    it('should return false if code is not unique', async () => {
      mockQueryBuilder.getCount.mockResolvedValue(1);

      const result = await repository.isCodeUniqueGlobally('EXISTING');

      expect(result).toBe(false);
    });
  });

  describe('hasTrades', () => {
    it('should return true if asset has trades', async () => {
      mockQueryBuilder.getCount.mockResolvedValue(1);

      const result = await repository.hasTrades('test-asset-id');

      expect(mockRepository.createQueryBuilder).toHaveBeenCalledWith('asset');
      expect(mockQueryBuilder.leftJoin).toHaveBeenCalledWith('asset.trades', 'trade');
      expect(mockQueryBuilder.where).toHaveBeenCalledWith('asset.id = :id', { id: 'test-asset-id' });
      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith('trade.tradeId IS NOT NULL');
      expect(result).toBe(true);
    });

    it('should return false if asset has no trades', async () => {
      mockQueryBuilder.getCount.mockResolvedValue(0);

      const result = await repository.hasTrades('test-asset-id');

      expect(result).toBe(false);
    });
  });

  describe('getAssetStatistics', () => {
    it('should return asset statistics', async () => {
      const assets = [
        { ...mockAsset, type: AssetType.STOCK, getTotalValue: () => 1000 },
        { ...mockAsset, type: AssetType.BOND, getTotalValue: () => 2000 },
        { ...mockAsset, type: AssetType.STOCK, getTotalValue: () => 1500 },
      ];

      jest.spyOn(repository, 'findByUserId').mockResolvedValue(assets as Asset[]);

      const result = await repository.getAssetStatistics('test-user-id');

      expect(result).toEqual({
        totalAssets: 3,
        assetsByType: {
          [AssetType.STOCK]: 2,
          [AssetType.BOND]: 1,
        },
        totalValue: 4500,
        averageValue: 1500,
      });
    });
  });

  describe('findByValueRange', () => {
    it('should find assets by value range', async () => {
      const assets = [mockAsset];
      mockQueryBuilder.getMany.mockResolvedValue(assets);

      const result = await repository.findByValueRange(1000, 2000);

      expect(mockRepository.createQueryBuilder).toHaveBeenCalledWith('asset');
      expect(mockQueryBuilder.where).toHaveBeenCalledWith('asset.currentValue >= :minValue', { minValue: 1000 });
      expect(mockQueryBuilder.andWhere).toHaveBeenCalledWith('asset.currentValue <= :maxValue', { maxValue: 2000 });
      expect(mockQueryBuilder.orderBy).toHaveBeenCalledWith('asset.currentValue', 'DESC');
      expect(result).toEqual(assets);
    });
  });

  describe('findRecent', () => {
    it('should find recent assets', async () => {
      const assets = [mockAsset];
      mockRepository.find.mockResolvedValue(assets);

      const result = await repository.findRecent(5);

      expect(mockRepository.find).toHaveBeenCalledWith({
        where: {},
        order: { createdAt: 'DESC' },
        take: 5,
      });
      expect(result).toEqual(assets);
    });

    it('should find recent assets with user filter', async () => {
      const assets = [mockAsset];
      mockRepository.find.mockResolvedValue(assets);

      const result = await repository.findRecent(5, 'test-user-id');

      expect(mockRepository.find).toHaveBeenCalledWith({
        where: { createdBy: 'test-user-id' },
        order: { createdAt: 'DESC' },
        take: 5,
      });
      expect(result).toEqual(assets);
    });
  });
});
