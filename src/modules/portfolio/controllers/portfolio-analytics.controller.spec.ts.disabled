import { Test, TestingModule } from '@nestjs/testing';
import { PortfolioAnalyticsController } from './portfolio-analytics.controller';
import { PortfolioAnalyticsService } from '../services/portfolio-analytics.service';
import { PortfolioService } from '../services/portfolio.service';
import { testUtils } from '../../../../test/utils/test-helpers';

describe('PortfolioAnalyticsController', () => {
  let controller: PortfolioAnalyticsController;
  let mockPortfolioAnalyticsService: jest.Mocked<PortfolioAnalyticsService>;
  let mockPortfolioService: jest.Mocked<PortfolioService>;

  beforeEach(async () => {
    // Create mock services
    mockPortfolioAnalyticsService = {
      getPerformanceSummary: jest.fn(),
      calculateROE: jest.fn(),
      calculateTWR: jest.fn(),
      calculateReturnHistory: jest.fn(),
      generateNavSnapshot: jest.fn(),
    } as any;

    mockPortfolioService = {
      getAssetAllocation: jest.fn(),
      getPortfolioDetails: jest.fn(),
    } as any;

    const module: TestingModule = await Test.createTestingModule({
      controllers: [PortfolioAnalyticsController],
      providers: [
        {
          provide: PortfolioAnalyticsService,
          useValue: mockPortfolioAnalyticsService,
        },
        {
          provide: PortfolioService,
          useValue: mockPortfolioService,
        },
      ],
    }).compile();

    controller = module.get<PortfolioAnalyticsController>(PortfolioAnalyticsController);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getPerformanceAnalytics', () => {
    it('should return performance analytics with default period', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 5.2,
        roe1Month: 2.1,
        roe3Month: 8.5,
        roe1Year: 15.3,
        twr1Year: 14.8,
      };

      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);
      mockPortfolioAnalyticsService.calculateROE.mockResolvedValue(15.3);
      mockPortfolioAnalyticsService.calculateTWR.mockResolvedValue(14.8);

      // Act
      const result = await controller.getPerformanceAnalytics(portfolioId);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        period: '1Y',
        period_start: expect.any(String),
        period_end: expect.any(String),
        ...performanceSummary,
        period_roe: 15.3,
        period_twr: 14.8,
        calculated_at: expect.any(String),
      });
      expect(mockPortfolioAnalyticsService.getPerformanceSummary).toHaveBeenCalledWith(portfolioId);
      expect(mockPortfolioAnalyticsService.calculateROE).toHaveBeenCalled();
      expect(mockPortfolioAnalyticsService.calculateTWR).toHaveBeenCalled();
    });

    it('should return performance analytics with 1M period', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 2.1,
        roe1Month: 2.1,
        roe3Month: 8.5,
        roe1Year: 15.3,
        twr1Year: 14.8,
      };

      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);
      mockPortfolioAnalyticsService.calculateROE.mockResolvedValue(2.1);
      mockPortfolioAnalyticsService.calculateTWR.mockResolvedValue(2.0);

      // Act
      const result = await controller.getPerformanceAnalytics(portfolioId, '1M');

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        period: '1M',
        period_start: expect.any(String),
        period_end: expect.any(String),
        ...performanceSummary,
        period_roe: 2.1,
        period_twr: 2.0,
        calculated_at: expect.any(String),
      });
    });

    it('should return performance analytics with 3M period', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 2.1,
        roe1Month: 2.1,
        roe3Month: 8.5,
        roe1Year: 15.3,
        twr1Year: 14.8,
      };

      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);
      mockPortfolioAnalyticsService.calculateROE.mockResolvedValue(8.5);
      mockPortfolioAnalyticsService.calculateTWR.mockResolvedValue(8.2);

      // Act
      const result = await controller.getPerformanceAnalytics(portfolioId, '3M');

      // Assert
      expect(result.period).toBe('3M');
      expect(result.period_roe).toBe(8.5);
      expect(result.period_twr).toBe(8.2);
    });

    it('should return performance analytics with 6M period', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 2.1,
        roe1Month: 2.1,
        roe3Month: 8.5,
        roe1Year: 15.3,
        twr1Year: 14.8,
      };

      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);
      mockPortfolioAnalyticsService.calculateROE.mockResolvedValue(12.0);
      mockPortfolioAnalyticsService.calculateTWR.mockResolvedValue(11.5);

      // Act
      const result = await controller.getPerformanceAnalytics(portfolioId, '6M');

      // Assert
      expect(result.period).toBe('6M');
      expect(result.period_roe).toBe(12.0);
      expect(result.period_twr).toBe(11.5);
    });

    it('should handle service errors', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const error = new Error('Portfolio not found');
      mockPortfolioAnalyticsService.getPerformanceSummary.mockRejectedValue(error);

      // Act & Assert
      await expect(controller.getPerformanceAnalytics(portfolioId)).rejects.toThrow(
        'Portfolio not found',
      );
    });
  });

  describe('getAllocationAnalytics', () => {
    it('should return allocation analytics grouped by type', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const allocation = [
        { assetType: 'STOCK', totalValue: 600000, percentage: 60 },
        { assetType: 'BOND', totalValue: 300000, percentage: 30 },
        { assetType: 'CASH', totalValue: 100000, percentage: 10 },
      ];
      const portfolio = testUtils.fixtures.portfolio({
        portfolioId: portfolioId,
        total_value: 1000000,
      });

      mockPortfolioService.getAssetAllocation.mockResolvedValue(allocation);
      mockPortfolioService.getPortfolioDetails.mockResolvedValue(portfolio);

      // Act
      const result = await controller.getAllocationAnalytics(portfolioId);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        total_value: 1000000,
        allocation: {
          stock: { percentage: 60, value: 600000 },
          bond: { percentage: 30, value: 300000 },
          cash: { percentage: 10, value: 100000 },
        },
        group_by: 'type',
        calculated_at: expect.any(String),
      });
      expect(mockPortfolioService.getAssetAllocation).toHaveBeenCalledWith(portfolioId);
      expect(mockPortfolioService.getPortfolioDetails).toHaveBeenCalledWith(portfolioId);
    });

    it('should return allocation analytics grouped by class', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const allocation = [
        { assetType: 'STOCK', totalValue: 600000, percentage: 60 },
        { assetType: 'BOND', totalValue: 300000, percentage: 30 },
        { assetType: 'CASH', totalValue: 100000, percentage: 10 },
      ];
      const portfolio = testUtils.fixtures.portfolio({
        portfolioId: portfolioId,
        total_value: 1000000,
      });

      mockPortfolioService.getAssetAllocation.mockResolvedValue(allocation);
      mockPortfolioService.getPortfolioDetails.mockResolvedValue(portfolio);

      // Act
      const result = await controller.getAllocationAnalytics(portfolioId, 'class');

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        total_value: 1000000,
        allocation: allocation, // Should return original allocation for class grouping
        group_by: 'class',
        calculated_at: expect.any(String),
      });
    });

    it('should handle empty allocation', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const allocation = [];
      const portfolio = testUtils.fixtures.portfolio({
        portfolioId: portfolioId,
        total_value: 0,
      });

      mockPortfolioService.getAssetAllocation.mockResolvedValue(allocation);
      mockPortfolioService.getPortfolioDetails.mockResolvedValue(portfolio);

      // Act
      const result = await controller.getAllocationAnalytics(portfolioId);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        total_value: 0,
        allocation: {},
        group_by: 'type',
        calculated_at: expect.any(String),
      });
    });

    it('should handle service errors', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const error = new Error('Portfolio not found');
      mockPortfolioService.getAssetAllocation.mockRejectedValue(error);

      // Act & Assert
      await expect(controller.getAllocationAnalytics(portfolioId)).rejects.toThrow(
        'Portfolio not found',
      );
    });
  });

  describe('getHistoricalData', () => {
    it('should return historical data with default parameters', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const returnHistory = [
        { assetType: 'STOCK', return: 5.2 },
        { assetType: 'BOND', return: 2.1 },
        { assetType: 'CASH', return: 0.5 },
      ];
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 2.1,
        roe1Month: 2.1,
        roe3Month: 8.5,
        roe1Year: 15.3,
        twr1Year: 14.8,
      };

      mockPortfolioAnalyticsService.calculateReturnHistory.mockResolvedValue(returnHistory);
      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);

      // Act
      const result = await controller.getHistoricalData(portfolioId);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        period: {
          start_date: expect.any(String),
          end_date: expect.any(String),
        },
        return_history: returnHistory,
        performance_summary: performanceSummary,
        limit: 30,
        retrieved_at: expect.any(String),
      });
      expect(mockPortfolioAnalyticsService.calculateReturnHistory).toHaveBeenCalled();
      expect(mockPortfolioAnalyticsService.getPerformanceSummary).toHaveBeenCalledWith(portfolioId);
    });

    it('should return historical data with custom parameters', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const startDate = '2024-01-01';
      const endDate = '2024-01-31';
      const limit = 50;
      const returnHistory = [
        { assetType: 'STOCK', return: 5.2 },
        { assetType: 'BOND', return: 2.1 },
      ];
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 2.1,
        roe1Month: 2.1,
        roe3Month: 8.5,
        roe1Year: 15.3,
        twr1Year: 14.8,
      };

      mockPortfolioAnalyticsService.calculateReturnHistory.mockResolvedValue(returnHistory);
      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);

      // Act
      const result = await controller.getHistoricalData(portfolioId, startDate, endDate, limit);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        period: {
          start_date: expect.any(String),
          end_date: expect.any(String),
        },
        return_history: returnHistory,
        performance_summary: performanceSummary,
        limit: 50,
        retrieved_at: expect.any(String),
      });
    });

    it('should handle empty return history', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const returnHistory = [];
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 0,
        roe1Month: 0,
        roe3Month: 0,
        roe1Year: 0,
        twr1Year: 0,
      };

      mockPortfolioAnalyticsService.calculateReturnHistory.mockResolvedValue(returnHistory);
      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);

      // Act
      const result = await controller.getHistoricalData(portfolioId);

      // Assert
      expect(result.return_history).toEqual([]);
      expect(result.performance_summary).toEqual(performanceSummary);
    });

    it('should handle service errors', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const error = new Error('Historical data not available');
      mockPortfolioAnalyticsService.calculateReturnHistory.mockRejectedValue(error);

      // Act & Assert
      await expect(controller.getHistoricalData(portfolioId)).rejects.toThrow(
        'Historical data not available',
      );
    });
  });

  describe('generateNavSnapshot', () => {
    it('should generate NAV snapshot with current date', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const navSnapshot = testUtils.fixtures.navSnapshot({
        portfolioId: portfolioId,
        nav_date: new Date(),
        nav_value: 1000000,
        cash_balance: 100000,
        total_value: 1000000,
      });

      mockPortfolioAnalyticsService.generateNavSnapshot.mockResolvedValue(navSnapshot);

      // Act
      const result = await controller.generateNavSnapshot(portfolioId);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        snapshot: navSnapshot,
        generated_at: expect.any(String),
      });
      expect(mockPortfolioAnalyticsService.generateNavSnapshot).toHaveBeenCalledWith(
        portfolioId,
        expect.any(Date),
      );
    });

    it('should generate NAV snapshot with specific date', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const snapshotDate = '2024-01-15';
      const navSnapshot = testUtils.fixtures.navSnapshot({
        portfolioId: portfolioId,
        nav_date: new Date(snapshotDate),
        nav_value: 1000000,
        cash_balance: 100000,
        total_value: 1000000,
      });

      mockPortfolioAnalyticsService.generateNavSnapshot.mockResolvedValue(navSnapshot);

      // Act
      const result = await controller.generateNavSnapshot(portfolioId, snapshotDate);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        snapshot: navSnapshot,
        generated_at: expect.any(String),
      });
      expect(mockPortfolioAnalyticsService.generateNavSnapshot).toHaveBeenCalledWith(
        portfolioId,
        new Date(snapshotDate),
      );
    });

    it('should handle service errors', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const error = new Error('Portfolio not found');
      mockPortfolioAnalyticsService.generateNavSnapshot.mockRejectedValue(error);

      // Act & Assert
      await expect(controller.generateNavSnapshot(portfolioId)).rejects.toThrow(
        'Portfolio not found',
      );
    });
  });

  describe('getAnalyticsReport', () => {
    it('should return comprehensive analytics report', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 2.1,
        roe1Month: 2.1,
        roe3Month: 8.5,
        roe1Year: 15.3,
        twr1Year: 14.8,
      };
      const allocation = [
        { assetType: 'STOCK', totalValue: 600000, percentage: 60 },
        { assetType: 'BOND', totalValue: 300000, percentage: 30 },
        { assetType: 'CASH', totalValue: 100000, percentage: 10 },
      ];
      const portfolio = testUtils.fixtures.portfolio({
        portfolioId: portfolioId,
        name: 'Test Portfolio',
        total_value: 1000000,
        cash_balance: 100000,
        unrealized_pl: 50000,
        realized_pl: 25000,
      });

      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);
      mockPortfolioService.getAssetAllocation.mockResolvedValue(allocation);
      mockPortfolioService.getPortfolioDetails.mockResolvedValue(portfolio);

      // Act
      const result = await controller.getAnalyticsReport(portfolioId);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        portfolio_name: 'Test Portfolio',
        report_date: expect.any(String),
        performance: performanceSummary,
        allocation: {
          stock: 60,
          bond: 30,
          cash: 10,
        },
        summary: {
          total_value: 1000000,
          cash_balance: 100000,
          unrealized_pl: 50000,
          realized_pl: 25000,
          asset_count: 3,
        },
      });
      expect(mockPortfolioAnalyticsService.getPerformanceSummary).toHaveBeenCalledWith(portfolioId);
      expect(mockPortfolioService.getAssetAllocation).toHaveBeenCalledWith(portfolioId);
      expect(mockPortfolioService.getPortfolioDetails).toHaveBeenCalledWith(portfolioId);
    });

    it('should handle empty allocation in report', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const performanceSummary = {
        currentNAV: 100000,
        weekOnWeekChange: 0,
        roe1Month: 0,
        roe3Month: 0,
        roe1Year: 0,
        twr1Year: 0,
      };
      const allocation = [];
      const portfolio = testUtils.fixtures.portfolio({
        portfolioId: portfolioId,
        name: 'Empty Portfolio',
        total_value: 100000,
        cash_balance: 100000,
        unrealized_pl: 0,
        realized_pl: 0,
      });

      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);
      mockPortfolioService.getAssetAllocation.mockResolvedValue(allocation);
      mockPortfolioService.getPortfolioDetails.mockResolvedValue(portfolio);

      // Act
      const result = await controller.getAnalyticsReport(portfolioId);

      // Assert
      expect(result).toEqual({
        portfolioId: portfolioId,
        portfolio_name: 'Empty Portfolio',
        report_date: expect.any(String),
        performance: performanceSummary,
        allocation: {},
        summary: {
          total_value: 100000,
          cash_balance: 100000,
          unrealized_pl: 0,
          realized_pl: 0,
          asset_count: 0,
        },
      });
    });

    it('should handle service errors', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const error = new Error('Portfolio not found');
      mockPortfolioAnalyticsService.getPerformanceSummary.mockRejectedValue(error);

      // Act & Assert
      await expect(controller.getAnalyticsReport(portfolioId)).rejects.toThrow(
        'Portfolio not found',
      );
    });
  });

  describe('Edge Cases and Error Handling', () => {
    it('should handle malformed UUID in getPerformanceAnalytics', async () => {
      // Arrange
      const invalidId = 'invalid-uuid';
      const error = new Error('Invalid UUID format');
      mockPortfolioAnalyticsService.getPerformanceSummary.mockRejectedValue(error);

      // Act & Assert
      await expect(controller.getPerformanceAnalytics(invalidId)).rejects.toThrow(
        'Invalid UUID format',
      );
    });

    it('should handle invalid date format in getHistoricalData', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const invalidDate = 'invalid-date';
      const returnHistory = [];
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 0,
        roe1Month: 0,
        roe3Month: 0,
        roe1Year: 0,
        twr1Year: 0,
      };

      mockPortfolioAnalyticsService.calculateReturnHistory.mockResolvedValue(returnHistory);
      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);

      // Act & Assert
      // Should throw an error when invalid date is passed
      await expect(controller.getHistoricalData(portfolioId, invalidDate)).rejects.toThrow(
        'Invalid time value',
      );
    });

    it('should handle invalid date format in generateNavSnapshot', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const invalidDate = 'invalid-date';
      const navSnapshot = testUtils.fixtures.navSnapshot({
        portfolioId: portfolioId,
        nav_date: new Date(invalidDate),
        nav_value: 1000000,
        cash_balance: 100000,
        total_value: 1000000,
      });

      mockPortfolioAnalyticsService.generateNavSnapshot.mockResolvedValue(navSnapshot);

      // Act
      const result = await controller.generateNavSnapshot(portfolioId, invalidDate);

      // Assert
      // The service should handle the invalid date and return a snapshot
      expect(result).toHaveProperty('portfolioId', portfolioId);
      expect(result).toHaveProperty('snapshot');
      expect(result).toHaveProperty('generated_at');
      expect(mockPortfolioAnalyticsService.generateNavSnapshot).toHaveBeenCalledWith(
        portfolioId,
        expect.any(Date),
      );
    });

    it('should handle concurrent service calls in getAnalyticsReport', async () => {
      // Arrange
      const portfolioId = '550e8400-e29b-41d4-a716-446655440000';
      const performanceSummary = {
        currentNAV: 1000000,
        weekOnWeekChange: 2.1,
        roe1Month: 2.1,
        roe3Month: 8.5,
        roe1Year: 15.3,
        twr1Year: 14.8,
      };
      const allocation = [
        { assetType: 'STOCK', totalValue: 600000, percentage: 60 },
      ];
      const portfolio = testUtils.fixtures.portfolio({
        portfolioId: portfolioId,
        name: 'Test Portfolio',
        total_value: 1000000,
        cash_balance: 100000,
        unrealized_pl: 50000,
        realized_pl: 25000,
      });

      // Mock services to resolve in different orders to test Promise.all
      mockPortfolioAnalyticsService.getPerformanceSummary.mockResolvedValue(performanceSummary);
      mockPortfolioService.getAssetAllocation.mockResolvedValue(allocation);
      mockPortfolioService.getPortfolioDetails.mockResolvedValue(portfolio);

      // Act
      const result = await controller.getAnalyticsReport(portfolioId);

      // Assert
      expect(result).toHaveProperty('portfolioId', portfolioId);
      expect(result).toHaveProperty('performance', performanceSummary);
      expect(result).toHaveProperty('allocation');
      expect(result).toHaveProperty('summary');
      
      // Verify all services were called
      expect(mockPortfolioAnalyticsService.getPerformanceSummary).toHaveBeenCalledWith(portfolioId);
      expect(mockPortfolioService.getAssetAllocation).toHaveBeenCalledWith(portfolioId);
      expect(mockPortfolioService.getPortfolioDetails).toHaveBeenCalledWith(portfolioId);
    });
  });
});
