import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { INestApplication } from '@nestjs/common';
import { Repository } from 'typeorm';
import { getRepositoryToken } from '@nestjs/typeorm';
import { TradingService } from '../../services/trading.service';
import { PositionService } from '../../services/position.service';
import { RiskManagementService } from '../../services/risk-management.service';
import { FIFOEngine } from '../../engines/fifo-engine';
import { LIFOEngine } from '../../engines/lifo-engine';
import { Trade, TradeSide, TradeType, TradeSource } from '../../entities/trade.entity';
import { TradeDetail } from '../../entities/trade-detail.entity';
import { AssetTarget } from '../../entities/asset-target.entity';
import { PortfolioAsset } from '../../../portfolio/entities/portfolio-asset.entity';
import { Portfolio } from '../../../portfolio/entities/portfolio.entity';
import { Asset } from '../../../asset/entities/asset.entity';
import { Account } from '../../../shared/entities/account.entity';

describe('Trading Integration Tests', () => {
  let app: INestApplication;
  let tradingService: TradingService;
  let positionService: PositionService;
  let riskManagementService: RiskManagementService;
  let fifoEngine: FIFOEngine;
  let lifoEngine: LIFOEngine;
  let tradeRepository: Repository<Trade>;
  let tradeDetailRepository: Repository<TradeDetail>;
  let portfolioAssetRepository: Repository<PortfolioAsset>;
  let assetTargetRepository: Repository<AssetTarget>;

  const testDatabaseConfig = {
    type: 'sqlite' as const,
    database: ':memory:',
    entities: [Trade, TradeDetail, AssetTarget, PortfolioAsset, Portfolio, Asset, Account],
    synchronize: true,
    logging: false,
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        TypeOrmModule.forRoot(testDatabaseConfig),
        TypeOrmModule.forFeature([Trade, TradeDetail, AssetTarget, PortfolioAsset, Portfolio, Asset, Account]),
      ],
      providers: [
        TradingService,
        PositionService,
        RiskManagementService,
        FIFOEngine,
        LIFOEngine,
      ],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    tradingService = moduleFixture.get<TradingService>(TradingService);
    positionService = moduleFixture.get<PositionService>(PositionService);
    riskManagementService = moduleFixture.get<RiskManagementService>(RiskManagementService);
    fifoEngine = moduleFixture.get<FIFOEngine>(FIFOEngine);
    lifoEngine = moduleFixture.get<LIFOEngine>(LIFOEngine);
    tradeRepository = moduleFixture.get<Repository<Trade>>(getRepositoryToken(Trade));
    tradeDetailRepository = moduleFixture.get<Repository<TradeDetail>>(getRepositoryToken(TradeDetail));
    portfolioAssetRepository = moduleFixture.get<Repository<PortfolioAsset>>(getRepositoryToken(PortfolioAsset));
    assetTargetRepository = moduleFixture.get<Repository<AssetTarget>>(getRepositoryToken(AssetTarget));
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    // Clean up database before each test
    await tradeDetailRepository.delete({});
    await tradeRepository.delete({});
    await portfolioAssetRepository.delete({});
    await assetTargetRepository.delete({});
  });

  describe('Complete Trade Creation Workflow', () => {
    it('should create a buy trade and update position correctly', async () => {
      const createTradeDto = {
        portfolioId: 'portfolio-1',
        assetId: 'asset-1',
        trade_date: new Date().toISOString(),
        side: TradeSide.BUY,
        quantity: 100,
        price: 50.0,
        fee: 5.0,
        tax: 2.5,
        trade_type: TradeType.NORMAL,
        source: TradeSource.MANUAL,
      };

      // Create the trade
      const trade = await tradingService.createTrade(createTradeDto);
      expect(trade).toBeDefined();
      expect(trade.portfolioId).toBe('portfolio-1');
      expect(trade.assetId).toBe('asset-1');
      expect(trade.side).toBe(TradeSide.BUY);
      expect(trade.quantity).toBe(100);
      expect(trade.price).toBe(50.0);

      // Verify trade was saved to database
      const savedTrade = await tradeRepository.findOne({ where: { trade_id: trade.trade_id } });
      expect(savedTrade).toBeDefined();
      expect(savedTrade?.portfolioId).toBe('portfolio-1');
    });

    it('should create a sell trade and update position correctly', async () => {
      // First create a buy trade to establish position
      const buyTradeDto = {
        portfolioId: 'portfolio-1',
        assetId: 'asset-1',
        trade_date: new Date().toISOString(),
        side: TradeSide.BUY,
        quantity: 100,
        price: 50.0,
        fee: 5.0,
        tax: 2.5,
        trade_type: TradeType.NORMAL,
        source: TradeSource.MANUAL,
      };

      await tradingService.createTrade(buyTradeDto);

      // Now create a sell trade
      const sellTradeDto = {
        portfolioId: 'portfolio-1',
        assetId: 'asset-1',
        trade_date: new Date().toISOString(),
        side: TradeSide.SELL,
        quantity: 50,
        price: 60.0,
        fee: 3.0,
        tax: 1.5,
        trade_type: TradeType.NORMAL,
        source: TradeSource.MANUAL,
      };

      const sellTrade = await tradingService.createTrade(sellTradeDto);
      expect(sellTrade).toBeDefined();
      expect(sellTrade.side).toBe(TradeSide.SELL);
      expect(sellTrade.quantity).toBe(50);
      expect(sellTrade.price).toBe(60.0);
    });

    it('should handle multiple trades for the same asset', async () => {
      const trades = [
        {
          portfolioId: 'portfolio-1',
          assetId: 'asset-1',
          trade_date: new Date().toISOString(),
          side: TradeSide.BUY,
          quantity: 100,
          price: 50.0,
          fee: 5.0,
          tax: 2.5,
          trade_type: TradeType.NORMAL,
          source: TradeSource.MANUAL,
        },
        {
          portfolioId: 'portfolio-1',
          assetId: 'asset-1',
          trade_date: new Date().toISOString(),
          side: TradeSide.BUY,
          quantity: 50,
          price: 55.0,
          fee: 2.5,
          tax: 1.25,
          trade_type: TradeType.NORMAL,
          source: TradeSource.MANUAL,
        },
        {
          portfolioId: 'portfolio-1',
          assetId: 'asset-1',
          trade_date: new Date().toISOString(),
          side: TradeSide.SELL,
          quantity: 75,
          price: 60.0,
          fee: 3.75,
          tax: 1.875,
          trade_type: TradeType.NORMAL,
          source: TradeSource.MANUAL,
        },
      ];

      for (const tradeDto of trades) {
        const trade = await tradingService.createTrade(tradeDto);
        expect(trade).toBeDefined();
        expect(trade.portfolioId).toBe('portfolio-1');
        expect(trade.assetId).toBe('asset-1');
      }

      // Verify all trades were saved
      const savedTrades = await tradeRepository.find({
        where: { portfolioId: 'portfolio-1', assetId: 'asset-1' },
      });
      expect(savedTrades).toHaveLength(3);
    });
  });

  describe('Position Management Integration', () => {
    it('should calculate position correctly after multiple trades', async () => {
      // Create multiple trades
      const trades = [
        {
          portfolioId: 'portfolio-1',
          assetId: 'asset-1',
          trade_date: new Date().toISOString(),
          side: TradeSide.BUY,
          quantity: 100,
          price: 50.0,
          fee: 5.0,
          tax: 2.5,
          trade_type: TradeType.NORMAL,
          source: TradeSource.MANUAL,
        },
        {
          portfolioId: 'portfolio-1',
          assetId: 'asset-1',
          trade_date: new Date().toISOString(),
          side: TradeSide.BUY,
          quantity: 50,
          price: 55.0,
          fee: 2.5,
          tax: 1.25,
          trade_type: TradeType.NORMAL,
          source: TradeSource.MANUAL,
        },
        {
          portfolioId: 'portfolio-1',
          assetId: 'asset-1',
          trade_date: new Date().toISOString(),
          side: TradeSide.SELL,
          quantity: 75,
          price: 60.0,
          fee: 3.75,
          tax: 1.875,
          trade_type: TradeType.NORMAL,
          source: TradeSource.MANUAL,
        },
      ];

      for (const tradeDto of trades) {
        await tradingService.createTrade(tradeDto);
      }

      // Get all trades for the asset
      const allTrades = await tradeRepository.find({
        where: { portfolioId: 'portfolio-1', assetId: 'asset-1' },
      });

      // Separate buy and sell trades
      const buyTrades = allTrades.filter(trade => trade.side === TradeSide.BUY);
      const sellTrades = allTrades.filter(trade => trade.side === TradeSide.SELL);

      // Test FIFO engine with sell trades
      for (const sellTrade of sellTrades) {
        const fifoMatches = fifoEngine.matchTrades(sellTrade, buyTrades);
        expect(fifoMatches).toBeDefined();
        expect(fifoMatches.matchedDetails).toBeDefined();
        expect(fifoMatches.remainingQuantity).toBeGreaterThanOrEqual(0);
      }

      // Test LIFO engine with sell trades
      for (const sellTrade of sellTrades) {
        const lifoMatches = lifoEngine.matchTrades(sellTrade, buyTrades);
        expect(lifoMatches).toBeDefined();
        expect(lifoMatches.matchedDetails).toBeDefined();
        expect(lifoMatches.remainingQuantity).toBeGreaterThanOrEqual(0);
      }
    });
  });

  describe('Risk Management Integration', () => {
    it('should validate trade against risk limits', async () => {
      const tradeDto = {
        portfolioId: 'portfolio-1',
        assetId: 'asset-1',
        trade_date: new Date().toISOString(),
        side: TradeSide.BUY,
        quantity: 100,
        price: 50.0,
        fee: 5.0,
        tax: 2.5,
        trade_type: TradeType.NORMAL,
        source: TradeSource.MANUAL,
      };

      // This should not throw an error for a normal trade
      expect(async () => {
        await tradingService.createTrade(tradeDto);
      }).not.toThrow();
    });
  });

  describe('Error Handling Integration', () => {
    it('should handle invalid trade data gracefully', async () => {
      const invalidTradeDto = {
        portfolioId: 'portfolio-1',
        assetId: 'asset-1',
        trade_date: new Date().toISOString(),
        side: 'INVALID_SIDE' as any,
        quantity: -100, // Invalid negative quantity
        price: -50.0, // Invalid negative price
        fee: 5.0,
        tax: 2.5,
        trade_type: TradeType.NORMAL,
        source: TradeSource.MANUAL,
      };

      // This should throw an error for invalid data
      await expect(tradingService.createTrade(invalidTradeDto)).rejects.toThrow();
    });

    it('should handle missing required fields', async () => {
      const incompleteTradeDto = {
        portfolioId: 'portfolio-1',
        // Missing assetId
        trade_date: new Date().toISOString(),
        side: TradeSide.BUY,
        quantity: 100,
        price: 50.0,
        fee: 5.0,
        tax: 2.5,
        trade_type: TradeType.NORMAL,
        source: TradeSource.MANUAL,
      };

      // This should throw an error for missing required fields
      await expect(tradingService.createTrade(incompleteTradeDto as any)).rejects.toThrow();
    });
  });
});