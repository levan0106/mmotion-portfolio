import { validate } from 'class-validator';
import { CreateTradeDto } from '../trade.dto';
import { UpdateTradeDto } from '../trade.dto';
import { TradeSide, TradeType, TradeSource } from '../../entities/trade.entity';

describe('Trade DTOs', () => {
  describe('CreateTradeDto', () => {
    const validCreateTradeDto = {
      portfolioId: '550e8400-e29b-41d4-a716-446655440000',
      assetId: '86c2ae61-8f69-4608-a5fd-8fecb44ed2c5',
      trade_date: '2024-01-01T00:00:00.000Z',
      side: TradeSide.BUY,
      quantity: 100,
      price: 50.0,
      fee: 5.0,
      tax: 2.5,
      trade_type: TradeType.NORMAL,
      source: TradeSource.MANUAL,
    };

    it('should validate with all required fields', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, validCreateTradeDto);

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with minimal required fields', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, {
        portfolioId: '550e8400-e29b-41d4-a716-446655440000',
        assetId: '86c2ae61-8f69-4608-a5fd-8fecb44ed2c5',
        trade_date: '2024-01-01T00:00:00.000Z',
        side: TradeSide.BUY,
        quantity: 100,
        price: 50.0,
      });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when portfolio_id is missing', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, portfolioId: undefined });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('portfolioId');
    });

    it('should fail validation when portfolio_id is empty', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, portfolioId: '' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('portfolioId');
    });

    it('should fail validation when asset_id is missing', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, assetId: undefined });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('assetId');
    });

    it('should fail validation when asset_id is empty', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, assetId: '' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('assetId');
    });

    it('should fail validation when trade_date is missing', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, trade_date: undefined });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('trade_date');
    });

    it('should fail validation when trade_date is invalid', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, trade_date: 'invalid-date' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('trade_date');
    });

    it('should fail validation when side is missing', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, side: undefined });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('side');
    });

    it('should fail validation when side is invalid', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, side: 'INVALID' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('side');
    });

    it('should validate with valid BUY side', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, side: TradeSide.BUY });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with valid SELL side', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, side: TradeSide.SELL });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when quantity is missing', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, quantity: undefined });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('quantity');
    });

    it('should fail validation when quantity is zero', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, quantity: 0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('quantity');
    });

    it('should fail validation when quantity is negative', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, quantity: -100 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('quantity');
    });

    it('should validate with positive quantity', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, quantity: 100 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with decimal quantity', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, quantity: 100.5 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when price is missing', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, price: undefined });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('price');
    });

    it('should validate when price is zero', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, price: 0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when price is negative', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, price: -50.0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('price');
    });

    it('should validate with positive price', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, price: 50.0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with decimal price', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, price: 50.75 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with zero fee', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, fee: 0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with positive fee', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, fee: 5.0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when fee is negative', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, fee: -5.0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('fee');
    });

    it('should validate with zero tax', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, tax: 0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with positive tax', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, tax: 2.5 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when tax is negative', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, tax: -2.5 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('tax');
    });

    it('should validate with valid trade_type', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, trade_type: TradeType.NORMAL });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with valid trade_type OPTION', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, trade_type: TradeType.OPTION });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when trade_type is invalid', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, trade_type: 'INVALID' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('trade_type');
    });

    it('should validate with valid source', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, source: TradeSource.MANUAL });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with valid source API', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, source: TradeSource.API });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with valid source FILE', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, source: TradeSource.IMPORT });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when source is invalid', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, { ...validCreateTradeDto, source: 'INVALID' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('source');
    });

    it('should validate with multiple validation errors', async () => {
      const dto = new CreateTradeDto();
      Object.assign(dto, {
        portfolioId: '',
        assetId: '',
        trade_date: undefined,
        side: 'INVALID',
        quantity: -100,
        price: -50.0,
        fee: -5.0,
        tax: -2.5,
        trade_type: 'INVALID',
        source: 'INVALID',
      });

      const errors = await validate(dto);
      expect(errors.length).toBeGreaterThan(5);
    });
  });

  describe('UpdateTradeDto', () => {
    const validUpdateTradeDto = {
      portfolioId: '550e8400-e29b-41d4-a716-446655440000',
      assetId: '86c2ae61-8f69-4608-a5fd-8fecb44ed2c5',
      trade_date: '2024-01-01T00:00:00.000Z',
      side: TradeSide.BUY,
      quantity: 100,
      price: 50.0,
      fee: 5.0,
      tax: 2.5,
      trade_type: TradeType.NORMAL,
      source: TradeSource.MANUAL,
      notes: 'Test trade update',
    };

    it('should validate with all fields', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, validUpdateTradeDto);

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with empty object (all fields optional)', async () => {
      const dto = new UpdateTradeDto();

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with partial fields', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, {
        quantity: 150,
        price: 55.0,
      });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with portfolio_id and asset_id', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, {
        portfolioId: '550e8400-e29b-41d4-a716-446655440000',
        assetId: '86c2ae61-8f69-4608-a5fd-8fecb44ed2c5',
      });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when portfolio_id is invalid UUID', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, portfolioId: 'invalid-uuid' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('portfolioId');
    });

    it('should fail validation when asset_id is invalid UUID', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, assetId: 'invalid-uuid' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('assetId');
    });

    it('should fail validation when trade_date is invalid', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, trade_date: 'invalid-date' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('trade_date');
    });

    it('should fail validation when quantity is zero', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, quantity: 0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('quantity');
    });

    it('should fail validation when quantity is negative', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, quantity: -100 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('quantity');
    });

    it('should validate with positive quantity', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, quantity: 100 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with decimal quantity', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, quantity: 100.5 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate when price is zero', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, price: 0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when price is negative', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, price: -50.0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('price');
    });

    it('should validate with positive price', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, price: 50.0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with decimal price', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, price: 50.75 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with zero fee', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, fee: 0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with positive fee', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, fee: 5.0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when fee is negative', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, fee: -5.0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('fee');
    });

    it('should validate with zero tax', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, tax: 0 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with positive tax', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, tax: 2.5 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when tax is negative', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, tax: -2.5 });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('tax');
    });

    it('should validate with valid source', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, source: TradeSource.MANUAL });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with valid source API', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, source: TradeSource.API });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should validate with valid source FILE', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, source: TradeSource.IMPORT });

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation when source is invalid', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, { ...validUpdateTradeDto, source: 'INVALID' });

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('source');
    });

    it('should validate with multiple validation errors', async () => {
      const dto = new UpdateTradeDto();
      Object.assign(dto, {
        trade_date: 'invalid-date',
        quantity: -100,
        price: -50.0,
        fee: -5.0,
        tax: -2.5,
        source: 'INVALID',
      });

      const errors = await validate(dto);
      expect(errors.length).toBeGreaterThan(5);
    });
  });
});
