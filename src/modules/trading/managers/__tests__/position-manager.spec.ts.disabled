import { PositionManager, PositionMetrics, PositionUpdate } from '../position-manager';
import { PortfolioAsset } from '../../../portfolio/entities/portfolio-asset.entity';
import { Trade, TradeSide, TradeType } from '../../entities/trade.entity';
import { TradeDetail } from '../../entities/trade-detail.entity';

describe('PositionManager', () => {
  let positionManager: PositionManager;

  beforeEach(() => {
    positionManager = new PositionManager();
  });

  const createTrade = (
    tradeId: string,
    assetId: string,
    side: TradeSide,
    quantity: number,
    price: number,
    fee: number = 0,
    tax: number = 0,
    tradeDate: Date = new Date()
  ): Trade => ({
    trade_id: tradeId,
    portfolioId: 'portfolio-1',
    assetId: assetId,
    trade_date: tradeDate,
    side,
    quantity,
    price,
    fee,
    tax,
    trade_type: TradeType.NORMAL,
    source: 'manual',
    total_amount: quantity * price,
    total_cost: quantity * price + fee + tax,
    created_at: new Date(),
    updated_at: new Date(),
    asset: null,
    portfolio: null,
    sell_details: [],
    buy_details: [],
  });

  const createPortfolioAsset = (
    assetId: string,
    quantity: number,
    avgCost: number,
    marketValue: number = 0,
    unrealizedPl: number = 0
  ): PortfolioAsset => ({
    portfolioId: 'portfolio-1',
    assetId: assetId,
    quantity,
    avg_cost: avgCost,
    market_value: marketValue,
    unrealized_pl: unrealizedPl,
    updated_at: new Date(),
    asset: null,
    portfolio: null,
  });

  const createTradeDetail = (
    sellTradeId: string,
    buyTradeId: string,
    assetId: string,
    matchedQty: number,
    buyPrice: number,
    sellPrice: number,
    pnl: number
  ): TradeDetail => ({
    detail_id: 'detail-1',
    sell_trade_id: sellTradeId,
    buy_trade_id: buyTradeId,
    assetId: assetId,
    matched_qty: matchedQty,
    buy_price: buyPrice,
    sell_price: sellPrice,
    fee_tax: 0,
    pnl,
    created_at: new Date(),
    sell_trade: null,
    buy_trade: null,
    asset: null,
  } as TradeDetail);

  describe('updatePosition', () => {
    it('should create new position for first trade', () => {
      const trade = createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50);
      const marketPrice = 60;

      const result = positionManager.updatePosition(null, trade, marketPrice);

      expect(result).toEqual({
        assetId: 'asset-1',
        quantity: 100,
        avgCost: 50,
        marketValue: 6000, // 100 * 60
        unrealizedPl: 1000, // 6000 - (100 * 50)
        realizedPl: 0,
      });
    });

    it('should update position on buy trade', () => {
      const currentPosition = createPortfolioAsset('asset-1', 100, 50);
      const buyTrade = createTrade('trade-2', 'asset-1', TradeSide.BUY, 50, 60);
      const marketPrice = 70;

      const result = positionManager.updatePosition(currentPosition, buyTrade, marketPrice);

      expect(result.assetId).toBe('asset-1');
      expect(result.quantity).toBe(150); // 100 + 50
      expect(result.avgCost).toBeCloseTo(53.33, 2); // (100*50 + 50*60) / 150
      expect(result.marketValue).toBe(10500); // 150 * 70
      expect(result.unrealizedPl).toBeCloseTo(2500, 0); // 10500 - (150 * 53.33)
      expect(result.realizedPl).toBe(0); // Keep existing realized P&L
    });

    it('should update position on sell trade', () => {
      const currentPosition = createPortfolioAsset('asset-1', 100, 50);
      const sellTrade = createTrade('trade-3', 'asset-1', TradeSide.SELL, 30, 70);
      const marketPrice = 75;

      const result = positionManager.updatePosition(currentPosition, sellTrade, marketPrice);

      expect(result).toEqual({
        assetId: 'asset-1',
        quantity: 70, // 100 - 30
        avgCost: 50, // Remains the same
        marketValue: 5250, // 70 * 75
        unrealizedPl: 1750, // 5250 - (70 * 50)
        realizedPl: 600, // (30 * 70) - (30 * 50)
      });
    });

    it('should handle sell trade that exceeds current position', () => {
      const currentPosition = createPortfolioAsset('asset-1', 100, 50);
      const sellTrade = createTrade('trade-4', 'asset-1', TradeSide.SELL, 150, 70);
      const marketPrice = 75;

      const result = positionManager.updatePosition(currentPosition, sellTrade, marketPrice);

      expect(result.assetId).toBe('asset-1');
      expect(result.quantity).toBe(0); // Max(0, 100 - 150)
      expect(result.avgCost).toBe(0); // No quantity left
      expect(result.marketValue).toBe(0); // 0 * 75
      expect(result.unrealizedPl).toBe(0); // 0 - 0
      expect(result.realizedPl).toBeCloseTo(2000, 0); // (100 * 70) - (100 * 50) = 2000
    });
  });

  describe('calculateTotalQuantity', () => {
    it('should calculate total quantity correctly', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50),
        createTrade('trade-2', 'asset-1', TradeSide.BUY, 50, 60),
        createTrade('trade-3', 'asset-1', TradeSide.SELL, 30, 70),
        createTrade('trade-4', 'asset-1', TradeSide.SELL, 20, 75),
      ];

      const result = positionManager.calculateTotalQuantity(trades);

      expect(result).toBe(100); // 100 + 50 - 30 - 20
    });

    it('should handle empty trades array', () => {
      const result = positionManager.calculateTotalQuantity([]);
      expect(result).toBe(0);
    });

    it('should handle only buy trades', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50),
        createTrade('trade-2', 'asset-1', TradeSide.BUY, 50, 60),
      ];

      const result = positionManager.calculateTotalQuantity(trades);
      expect(result).toBe(150);
    });

    it('should handle only sell trades', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.SELL, 100, 50),
        createTrade('trade-2', 'asset-1', TradeSide.SELL, 50, 60),
      ];

      const result = positionManager.calculateTotalQuantity(trades);
      expect(result).toBe(-150);
    });
  });

  describe('calculateAverageCost', () => {
    it('should calculate average cost correctly', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50), // 5000 cost
        createTrade('trade-2', 'asset-1', TradeSide.BUY, 50, 60),  // 3000 cost
        createTrade('trade-3', 'asset-1', TradeSide.SELL, 30, 70), // Sell doesn't affect avg cost
      ];

      const result = positionManager.calculateAverageCost(trades);

      expect(result).toBeCloseTo(53.33, 2); // (5000 + 3000) / (100 + 50)
    });

    it('should handle empty trades array', () => {
      const result = positionManager.calculateAverageCost([]);
      expect(result).toBe(0);
    });

    it('should handle only sell trades', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.SELL, 100, 50),
        createTrade('trade-2', 'asset-1', TradeSide.SELL, 50, 60),
      ];

      const result = positionManager.calculateAverageCost(trades);
      expect(result).toBe(0);
    });

    it('should handle trades with fees and taxes', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50, 10, 5), // 5015 cost
        createTrade('trade-2', 'asset-1', TradeSide.BUY, 50, 60, 5, 2),   // 3007 cost
      ];

      const result = positionManager.calculateAverageCost(trades);

      expect(result).toBeCloseTo(53.48, 2); // (5015 + 3007) / (100 + 50)
    });
  });

  describe('calculateUnrealizedPL', () => {
    it('should calculate unrealized P&L correctly', () => {
      const position = createPortfolioAsset('asset-1', 100, 50);
      const marketPrice = 60;

      const result = positionManager.calculateUnrealizedPL(position, marketPrice);

      expect(result).toBe(1000); // (100 * 60) - (100 * 50)
    });

    it('should handle negative unrealized P&L', () => {
      const position = createPortfolioAsset('asset-1', 100, 50);
      const marketPrice = 40;

      const result = positionManager.calculateUnrealizedPL(position, marketPrice);

      expect(result).toBe(-1000); // (100 * 40) - (100 * 50)
    });

    it('should handle zero quantity position', () => {
      const position = createPortfolioAsset('asset-1', 0, 50);
      const marketPrice = 60;

      const result = positionManager.calculateUnrealizedPL(position, marketPrice);

      expect(result).toBe(0);
    });
  });

  describe('calculateRealizedPL', () => {
    it('should calculate realized P&L from trade details', () => {
      const tradeDetails = [
        createTradeDetail('sell-1', 'buy-1', 'asset-1', 50, 50, 60, 500),
        createTradeDetail('sell-2', 'buy-2', 'asset-1', 30, 55, 65, 300),
      ];

      const result = positionManager.calculateRealizedPL(tradeDetails);

      expect(result).toBe(800); // 500 + 300
    });

    it('should handle empty trade details', () => {
      const result = positionManager.calculateRealizedPL([]);
      expect(result).toBe(0);
    });

    it('should handle negative P&L', () => {
      const tradeDetails = [
        createTradeDetail('sell-1', 'buy-1', 'asset-1', 50, 50, 40, -500),
        createTradeDetail('sell-2', 'buy-2', 'asset-1', 30, 55, 60, 150),
      ];

      const result = positionManager.calculateRealizedPL(tradeDetails);

      expect(result).toBe(-350); // -500 + 150
    });
  });

  describe('getCurrentPositions', () => {
    it('should get current positions from trades', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50),
        createTrade('trade-2', 'asset-1', TradeSide.BUY, 50, 60),
        createTrade('trade-3', 'asset-1', TradeSide.SELL, 30, 70),
        createTrade('trade-4', 'asset-2', TradeSide.BUY, 200, 25),
      ];

      const marketPrices = { 'asset-1': 70, 'asset-2': 30 };

      const result = positionManager.getCurrentPositions(trades, marketPrices);

      expect(result).toHaveLength(2);

      // Check asset-1 position
      const asset1Position = result.find(p => p.totalQuantity === 120);
      expect(asset1Position.totalQuantity).toBe(120); // 100 + 50 - 30
      expect(asset1Position.totalCost).toBeCloseTo(6400, 0); // 120 * 53.33 (average cost)
      expect(asset1Position.averageCost).toBeCloseTo(53.33, 2);
      expect(asset1Position.marketValue).toBe(8400); // 120 * 70
      expect(asset1Position.unrealizedPl).toBeCloseTo(2000, 0); // 8400 - 6400
      expect(asset1Position.unrealizedPlPercentage).toBeCloseTo(31.25, 1); // (2000 / 6400) * 100
      expect(asset1Position.realizedPl).toBe(0);
      expect(asset1Position.totalPl).toBeCloseTo(2000, 0);

      // Check asset-2 position
      const asset2Position = result.find(p => p.totalQuantity === 200);
      expect(asset2Position).toEqual({
        totalQuantity: 200,
        totalCost: 5000, // 200 * 25
        averageCost: 25,
        marketValue: 6000, // 200 * 30
        unrealizedPl: 1000, // 6000 - 5000
        unrealizedPlPercentage: 20, // (1000 / 5000) * 100
        realizedPl: 0,
        totalPl: 1000,
      });
    });

    it('should filter out zero quantity positions', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50),
        createTrade('trade-2', 'asset-1', TradeSide.SELL, 100, 60), // Fully sold
        createTrade('trade-3', 'asset-2', TradeSide.BUY, 50, 30),
      ];

      const marketPrices = { 'asset-1': 70, 'asset-2': 35 };

      const result = positionManager.getCurrentPositions(trades, marketPrices);

      expect(result).toHaveLength(1);
      expect(result[0].totalQuantity).toBe(50);
    });

    it('should handle empty trades array', () => {
      const result = positionManager.getCurrentPositions([], {});
      expect(result).toHaveLength(0);
    });
  });

  describe('calculatePositionMetrics', () => {
    it('should calculate position metrics correctly', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50),
        createTrade('trade-2', 'asset-1', TradeSide.BUY, 50, 60),
        createTrade('trade-3', 'asset-1', TradeSide.SELL, 30, 70),
      ];

      const tradeDetails = [
        createTradeDetail('trade-3', 'trade-1', 'asset-1', 30, 50, 70, 600),
      ];

      const marketPrice = 75;

      const result = positionManager.calculatePositionMetrics(
        'asset-1',
        trades,
        marketPrice,
        tradeDetails
      );

      expect(result.totalQuantity).toBe(120); // 100 + 50 - 30
      expect(result.totalCost).toBeCloseTo(6400, 0); // 120 * 53.33
      expect(result.averageCost).toBeCloseTo(53.33, 2);
      expect(result.marketValue).toBe(9000); // 120 * 75
      expect(result.unrealizedPl).toBeCloseTo(2600, 0); // 9000 - 6400
      expect(result.unrealizedPlPercentage).toBeCloseTo(40.625, 1); // (2600 / 6400) * 100
      expect(result.realizedPl).toBe(600);
      expect(result.totalPl).toBeCloseTo(3200, 0); // 2600 + 600
    });

    it('should handle zero quantity position', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50),
        createTrade('trade-2', 'asset-1', TradeSide.SELL, 100, 60),
      ];

      const marketPrice = 75;

      const result = positionManager.calculatePositionMetrics(
        'asset-1',
        trades,
        marketPrice
      );

      expect(result.totalQuantity).toBe(0);
      expect(result.totalCost).toBe(0);
      expect(result.averageCost).toBe(0);
      expect(result.marketValue).toBe(0);
      expect(result.unrealizedPl).toBe(0);
      expect(result.unrealizedPlPercentage).toBe(0);
      expect(result.realizedPl).toBe(0);
      expect(result.totalPl).toBe(0);
    });

    it('should handle missing market price', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 100, 50),
      ];

      const marketPrice = 0; // No market price

      const result = positionManager.calculatePositionMetrics(
        'asset-1',
        trades,
        marketPrice
      );

      expect(result).toEqual({
        totalQuantity: 100,
        totalCost: 5000,
        averageCost: 50,
        marketValue: 0,
        unrealizedPl: -5000, // 0 - 5000
        unrealizedPlPercentage: -100, // (-5000 / 5000) * 100
        realizedPl: 0,
        totalPl: -5000,
      });
    });
  });

  describe('Edge cases and error handling', () => {
    it('should handle division by zero in average cost calculation', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.SELL, 100, 50), // Only sell trades
      ];

      const result = positionManager.calculateAverageCost(trades);
      expect(result).toBe(0);
    });

    it('should handle very small quantities', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 0.001, 50),
        createTrade('trade-2', 'asset-1', TradeSide.BUY, 0.002, 60),
      ];

      const result = positionManager.calculateTotalQuantity(trades);
      expect(result).toBeCloseTo(0.003, 6);
    });

    it('should handle very large numbers', () => {
      const trades = [
        createTrade('trade-1', 'asset-1', TradeSide.BUY, 1000000, 1000),
        createTrade('trade-2', 'asset-1', TradeSide.SELL, 500000, 1200),
      ];

      const result = positionManager.calculateTotalQuantity(trades);
      expect(result).toBe(500000);
    });
  });
});
