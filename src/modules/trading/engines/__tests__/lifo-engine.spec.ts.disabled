import { LIFOEngine } from '../lifo-engine';
import { TradeMatchResult } from '../fifo-engine';
import { Trade, TradeSide, TradeType } from '../../entities/trade.entity';
import { TradeDetail } from '../../entities/trade-detail.entity';

describe('LIFOEngine', () => {
  let lifoEngine: LIFOEngine;

  beforeEach(() => {
    lifoEngine = new LIFOEngine();
  });

  describe('matchTrades', () => {
    const createBuyTrade = (
      tradeId: string,
      quantity: number,
      price: number,
      tradeDate: string,
      fee: number = 0,
      tax: number = 0,
    ): Trade => ({
      trade_id: tradeId,
      portfolioId: 'portfolio-1',
      assetId: 'asset-1',
      trade_date: new Date(tradeDate),
      side: TradeSide.BUY,
      quantity,
      price,
      fee,
      tax,
      trade_type: TradeType.NORMAL,
      source: 'manual',
      total_amount: quantity * price,
      total_cost: quantity * price + fee + tax,
      created_at: new Date(),
      updated_at: new Date(),
      asset: null,
      portfolio: null,
      sell_details: [],
      buy_details: [],
    });

    const createSellTrade = (
      tradeId: string,
      quantity: number,
      price: number,
      tradeDate: string,
      fee: number = 0,
      tax: number = 0,
    ): Trade => ({
      trade_id: tradeId,
      portfolioId: 'portfolio-1',
      assetId: 'asset-1',
      trade_date: new Date(tradeDate),
      side: TradeSide.SELL,
      quantity,
      price,
      fee,
      tax,
      trade_type: TradeType.NORMAL,
      source: 'manual',
      total_amount: quantity * price,
      total_cost: quantity * price + fee + tax,
      created_at: new Date(),
      updated_at: new Date(),
      asset: null,
      portfolio: null,
      sell_details: [],
      buy_details: [],
    });

    it('should match trades using LIFO algorithm correctly', () => {
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 50, 50.0, '2024-01-01'), // Oldest
        createBuyTrade('buy-2', 80, 55.0, '2024-01-10'), // Middle
        createBuyTrade('buy-3', 30, 45.0, '2024-01-20'), // Newest
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0);
      expect(result.totalPnl).toBe(800); // (60-45)*30 + (60-55)*70 = 450 + 350 = 800
      expect(result.matchedDetails).toHaveLength(2);

      // Check first match (buy-3: 30 shares at 45.0 - newest first)
      expect(result.matchedDetails[0].buy_trade_id).toBe('buy-3');
      expect(result.matchedDetails[0].sell_trade_id).toBe('sell-1');
      expect(result.matchedDetails[0].matched_qty).toBe(30);
      expect(result.matchedDetails[0].buy_price).toBe(45.0);
      expect(result.matchedDetails[0].sell_price).toBe(60.0);
      expect(result.matchedDetails[0].pnl).toBe(450); // (60-45)*30

      // Check second match (buy-2: 70 shares at 55.0)
      expect(result.matchedDetails[1].buy_trade_id).toBe('buy-2');
      expect(result.matchedDetails[1].sell_trade_id).toBe('sell-1');
      expect(result.matchedDetails[1].matched_qty).toBe(70);
      expect(result.matchedDetails[1].buy_price).toBe(55.0);
      expect(result.matchedDetails[1].sell_price).toBe(60.0);
      expect(result.matchedDetails[1].pnl).toBe(350); // (60-55)*70
    });

    it('should handle partial matching with remaining quantity', () => {
      const sellTrade = createSellTrade('sell-1', 200, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 50, 50.0, '2024-01-01'),
        createBuyTrade('buy-2', 80, 55.0, '2024-01-10'),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(70); // 200 - 80 - 50
      expect(result.totalPnl).toBe(900); // (60-55)*80 + (60-50)*50 = 400 + 500 = 900
      expect(result.matchedDetails).toHaveLength(2);

      // Should match buy-2 first (newer), then buy-1 (older)
      expect(result.matchedDetails[0].matched_qty).toBe(80);
      expect(result.matchedDetails[1].matched_qty).toBe(50);
    });

    it('should handle no matching buy trades', () => {
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15');
      const buyTrades: Trade[] = [];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(100);
      expect(result.totalPnl).toBe(0);
      expect(result.matchedDetails).toHaveLength(0);
    });

    it('should handle sell trade with zero quantity', () => {
      const sellTrade = createSellTrade('sell-1', 0, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 50, 50.0, '2024-01-01'),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0);
      expect(result.totalPnl).toBe(0);
      expect(result.matchedDetails).toHaveLength(0);
    });

    it('should handle buy trades with zero quantity', () => {
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 0, 50.0, '2024-01-01'),
        createBuyTrade('buy-2', 50, 55.0, '2024-01-10'),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(50); // 100 - 50
      expect(result.totalPnl).toBe(250); // (60-55)*50
      expect(result.matchedDetails).toHaveLength(1);
      expect(result.matchedDetails[0].buy_trade_id).toBe('buy-2');
    });

    it('should filter out non-buy trades', () => {
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 50, 50.0, '2024-01-01'),
        createSellTrade('sell-2', 30, 45.0, '2024-01-10'), // This should be filtered out
        createBuyTrade('buy-2', 80, 55.0, '2024-01-20'),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0); // 100 - 80 - 50 (all matched)
      expect(result.totalPnl).toBe(600); // (60-55)*80 + (60-50)*50 = 400 + 200 = 600
      expect(result.matchedDetails).toHaveLength(2);
      expect(result.matchedDetails.every(detail => detail.buy_trade_id !== 'sell-2')).toBe(true);
    });

    it('should sort buy trades by trade_date (LIFO - newest first)', () => {
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-3', 30, 45.0, '2024-01-20'), // Newest
        createBuyTrade('buy-1', 50, 50.0, '2024-01-01'), // Oldest
        createBuyTrade('buy-2', 80, 55.0, '2024-01-10'), // Middle
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0); // 100 - 30 - 70 (all matched)
      expect(result.totalPnl).toBe(800); // (60-45)*30 + (60-55)*70 = 450 + 350 = 800
      expect(result.matchedDetails).toHaveLength(2);

      // Should match buy-3 first (newest), then buy-2 (middle)
      expect(result.matchedDetails[0].buy_trade_id).toBe('buy-3');
      expect(result.matchedDetails[1].buy_trade_id).toBe('buy-2');
    });

    it('should handle trades with fees and taxes', () => {
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15', 10.0, 5.0);
      const buyTrades = [
        createBuyTrade('buy-1', 50, 50.0, '2024-01-01', 5.0, 2.5),
        createBuyTrade('buy-2', 80, 55.0, '2024-01-10', 8.0, 4.0),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0); // 100 - 80 - 50 (all matched)
      expect(result.matchedDetails).toHaveLength(2);

      // Check fee and tax calculations
      expect(result.matchedDetails[0].fee_tax).toBeGreaterThan(0);
      expect(result.matchedDetails[1].fee_tax).toBeGreaterThan(0);
    });

    it('should handle negative P&L (loss)', () => {
      const sellTrade = createSellTrade('sell-1', 100, 40.0, '2024-01-15'); // Lower sell price
      const buyTrades = [
        createBuyTrade('buy-1', 50, 50.0, '2024-01-01'),
        createBuyTrade('buy-2', 80, 55.0, '2024-01-10'),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0); // 100 - 80 - 50 (all matched)
      expect(result.totalPnl).toBe(-1400); // (40-55)*80 + (40-50)*50 = -1200 + -200 = -1400
      expect(result.matchedDetails).toHaveLength(2);

      // Both matches should have negative P&L
      expect(result.matchedDetails[0].pnl).toBe(-1200); // (40-55)*80
      expect(result.matchedDetails[1].pnl).toBe(-200); // (40-50)*50
    });

    it('should handle exact quantity match', () => {
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 100, 50.0, '2024-01-01'), // Exact match
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0);
      expect(result.totalPnl).toBe(1000); // (60-50)*100
      expect(result.matchedDetails).toHaveLength(1);
      expect(result.matchedDetails[0].matched_qty).toBe(100);
    });

    it('should throw error for non-sell trade', () => {
      const buyTrade = createBuyTrade('buy-1', 100, 50.0, '2024-01-01');
      const buyTrades = [buyTrade];

      expect(() => lifoEngine.matchTrades(buyTrade, buyTrades)).toThrow(
        'LIFO matching can only be applied to SELL trades',
      );
    });

    it('should handle multiple trades with same date', () => {
      const sameDate = '2024-01-01';
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 30, 50.0, sameDate),
        createBuyTrade('buy-2', 40, 55.0, sameDate),
        createBuyTrade('buy-3', 50, 45.0, sameDate),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0);
      expect(result.totalPnl).toBe(950); // (60-45)*50 + (60-55)*40 + (60-50)*10 = 750 + 200 + 0 = 950
      expect(result.matchedDetails).toHaveLength(3);

      // Should match in reverse order (LIFO within same date)
      expect(result.matchedDetails[0].buy_trade_id).toBe('buy-1');
      expect(result.matchedDetails[1].buy_trade_id).toBe('buy-2');
      expect(result.matchedDetails[2].buy_trade_id).toBe('buy-3');
    });

    it('should handle very large quantities', () => {
      const sellTrade = createSellTrade('sell-1', 1000000, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 500000, 50.0, '2024-01-01'),
        createBuyTrade('buy-2', 800000, 55.0, '2024-01-10'),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0); // 1000000 - 800000 - 200000 (all matched)
      expect(result.totalPnl).toBe(6000000); // (60-55)*800000 + (60-50)*200000 = 4000000 + 2000000
      expect(result.matchedDetails).toHaveLength(2);
    });

    it('should handle decimal quantities and prices', () => {
      const sellTrade = createSellTrade('sell-1', 100.5, 60.25, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 50.25, 50.75, '2024-01-01'),
        createBuyTrade('buy-2', 80.75, 55.50, '2024-01-10'),
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0); // 100.5 - 80.75 - 19.75 (all matched)
      expect(result.totalPnl).toBeCloseTo(571.1875); // (60.25-55.50)*80.75 + (60.25-50.75)*19.75
      expect(result.matchedDetails).toHaveLength(2);
    });

    it('should demonstrate LIFO vs FIFO difference', () => {
      const sellTrade = createSellTrade('sell-1', 100, 60.0, '2024-01-15');
      const buyTrades = [
        createBuyTrade('buy-1', 50, 50.0, '2024-01-01'), // Oldest, lowest price
        createBuyTrade('buy-2', 50, 55.0, '2024-01-10'), // Newest, higher price
      ];

      const result: TradeMatchResult = lifoEngine.matchTrades(sellTrade, buyTrades);

      expect(result.remainingQuantity).toBe(0);
      expect(result.totalPnl).toBe(750); // (60-55)*50 + (60-50)*50 = 250 + 500 = 750
      expect(result.matchedDetails).toHaveLength(2);

      // LIFO should match buy-2 first (newest), then buy-1 (oldest)
      expect(result.matchedDetails[0].buy_trade_id).toBe('buy-2');
      expect(result.matchedDetails[0].pnl).toBe(250); // (60-55)*50
      expect(result.matchedDetails[1].buy_trade_id).toBe('buy-1');
      expect(result.matchedDetails[1].pnl).toBe(500); // (60-50)*50
    });
  });

  describe('calculateFeeTax', () => {
    it('should calculate fee and tax proportionally', () => {
      const buyTrade = createBuyTrade('buy-1', 100, 50.0, '2024-01-01', 10.0, 5.0);
      const sellTrade = createSellTrade('sell-1', 50, 60.0, '2024-01-15', 5.0, 2.5);
      const matchedQuantity = 50;

      const feeTax = lifoEngine['calculateFeeTax'](buyTrade, sellTrade, matchedQuantity);

      // Buy trade: 10.0 fee + 5.0 tax = 15.0 total for 100 shares
      // Sell trade: 5.0 fee + 2.5 tax = 7.5 total for 50 shares
      // For 50 matched shares: (15.0 * 50/100) + (7.5 * 50/50) = 7.5 + 7.5 = 15.0
      expect(feeTax).toBe(15.0);
    });

    it('should handle zero fees and taxes', () => {
      const buyTrade = createBuyTrade('buy-1', 100, 50.0, '2024-01-01', 0, 0);
      const sellTrade = createSellTrade('sell-1', 50, 60.0, '2024-01-15', 0, 0);
      const matchedQuantity = 50;

      const feeTax = lifoEngine['calculateFeeTax'](buyTrade, sellTrade, matchedQuantity);

      expect(feeTax).toBe(0);
    });

    it('should handle partial matching with fees and taxes', () => {
      const buyTrade = createBuyTrade('buy-1', 100, 50.0, '2024-01-01', 20.0, 10.0);
      const sellTrade = createSellTrade('sell-1', 200, 60.0, '2024-01-15', 10.0, 5.0);
      const matchedQuantity = 75; // Partial match

      const feeTax = lifoEngine['calculateFeeTax'](buyTrade, sellTrade, matchedQuantity);

      // Buy trade: 30.0 total for 100 shares, for 75 shares: 30.0 * 75/100 = 22.5
      // Sell trade: 15.0 total for 200 shares, for 75 shares: 15.0 * 75/200 = 5.625
      // Total: 22.5 + 5.625 = 28.125
      expect(feeTax).toBeCloseTo(28.125);
    });
  });

  describe('calculatePnl', () => {
    it('should calculate P&L correctly', () => {
      const buyPrice = 50.0;
      const sellPrice = 60.0;
      const quantity = 100;
      const feeTax = 10.0;

      const pnl = lifoEngine['calculatePnl'](buyPrice, sellPrice, quantity, feeTax);

      // (60 - 50) * 100 - 10 = 1000 - 10 = 990
      expect(pnl).toBe(990);
    });

    it('should handle negative P&L', () => {
      const buyPrice = 60.0;
      const sellPrice = 50.0;
      const quantity = 100;
      const feeTax = 10.0;

      const pnl = lifoEngine['calculatePnl'](buyPrice, sellPrice, quantity, feeTax);

      // (50 - 60) * 100 - 10 = -1000 - 10 = -1010
      expect(pnl).toBe(-1010);
    });

    it('should handle zero P&L', () => {
      const buyPrice = 50.0;
      const sellPrice = 50.0;
      const quantity = 100;
      const feeTax = 0;

      const pnl = lifoEngine['calculatePnl'](buyPrice, sellPrice, quantity, feeTax);

      // (50 - 50) * 100 - 0 = 0
      expect(pnl).toBe(0);
    });

    it('should handle decimal prices and quantities', () => {
      const buyPrice = 50.75;
      const sellPrice = 60.25;
      const quantity = 100.5;
      const feeTax = 15.25;

      const pnl = lifoEngine['calculatePnl'](buyPrice, sellPrice, quantity, feeTax);

      // (60.25 - 50.75) * 100.5 - 15.25 = 9.5 * 100.5 - 15.25 = 954.75 - 15.25 = 939.5
      expect(pnl).toBeCloseTo(939.5);
    });
  });

  // Helper functions for creating test data
  const createBuyTrade = (
    tradeId: string,
    quantity: number,
    price: number,
    tradeDate: string,
    fee: number = 0,
    tax: number = 0,
  ): Trade => ({
    trade_id: tradeId,
    portfolioId: 'portfolio-1',
    assetId: 'asset-1',
    trade_date: new Date(tradeDate),
    side: TradeSide.BUY,
    quantity,
    price,
    fee,
    tax,
    trade_type: TradeType.NORMAL,
    source: 'manual',
    total_amount: quantity * price,
    total_cost: quantity * price + fee + tax,
    created_at: new Date(),
    updated_at: new Date(),
    asset: null,
    portfolio: null,
    sell_details: [],
    buy_details: [],
  });

  const createSellTrade = (
    tradeId: string,
    quantity: number,
    price: number,
    tradeDate: string,
    fee: number = 0,
    tax: number = 0,
  ): Trade => ({
    trade_id: tradeId,
    portfolioId: 'portfolio-1',
    assetId: 'asset-1',
    trade_date: new Date(tradeDate),
    side: TradeSide.SELL,
    quantity,
    price,
    fee,
    tax,
    trade_type: TradeType.NORMAL,
    source: 'manual',
    total_amount: quantity * price,
    total_cost: quantity * price + fee + tax,
    created_at: new Date(),
    updated_at: new Date(),
    asset: null,
    portfolio: null,
    sell_details: [],
    buy_details: [],
  });
});
