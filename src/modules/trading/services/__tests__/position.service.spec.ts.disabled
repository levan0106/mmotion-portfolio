import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { NotFoundException } from '@nestjs/common';
import { PositionService, PositionSummary } from '../position.service';
import { PortfolioAsset } from '../../../portfolio/entities/portfolio-asset.entity';
import { Portfolio } from '../../../portfolio/entities/portfolio.entity';
import { Trade } from '../../entities/trade.entity';
import { TradeDetail } from '../../entities/trade-detail.entity';
import { PositionManager } from '../../managers/position-manager';
import { TradeRepository } from '../../repositories/trade.repository';
import { TradeDetailRepository } from '../../repositories/trade-detail.repository';

describe('PositionService', () => {
  let service: PositionService;
  let mockPortfolioAssetRepository: jest.Mocked<Repository<PortfolioAsset>>;
  let mockPositionManager: jest.Mocked<PositionManager>;
  let mockTradeRepository: jest.Mocked<TradeRepository>;
  let mockTradeDetailRepository: jest.Mocked<TradeDetailRepository>;

  const mockPortfolio: Portfolio = {
    portfolioId: 'portfolio-1',
    name: 'Test Portfolio',
    account_id: 'account-1',
    base_currency: 'USD',
    total_value: 10000,
    cash_balance: 5000,
    unrealized_pl: 0,
    realized_pl: 0,
    created_at: new Date('2024-01-01'),
    updated_at: new Date('2024-01-01'),
    account: null,
    navSnapshots: [],
    cashFlows: [],
    trades: [],
    portfolioAssets: [],
  };

  const mockPortfolioAsset: PortfolioAsset = {
    portfolioId: 'portfolio-1',
    assetId: 'asset-1',
    quantity: 100,
    avg_cost: 50,
    market_value: 5000,
    unrealized_pl: 500,
    updated_at: new Date('2024-01-01'),
    portfolio: mockPortfolio,
    asset: {
      id: 'asset-1',
      name: 'Test Asset',
      symbol: 'TEST',
      type: 'STOCK' as any,
      portfolioId: 'portfolio-1',
      created_at: new Date('2024-01-01'),
      updated_at: new Date('2024-01-01'),
      createdBy: 'user-1',
      updatedBy: 'user-1',
      initialValue: 1000,
      initialQuantity: 100,
      trades: [],
      portfolioAssets: [],
      getTotalValue: jest.fn().mockReturnValue(1000),
      getTotalQuantity: jest.fn().mockReturnValue(100),
      hasTrades: jest.fn().mockReturnValue(false),
      getDisplayName: jest.fn().mockReturnValue('Test Asset (TEST)'),
      toJSON: jest.fn().mockReturnValue({}),
    } as any,
  };

  const mockPositionSummary: PositionSummary = {
    assetId: 'asset-1',
    assetSymbol: 'TEST',
    assetName: 'Test Asset',
    quantity: 100,
    avgCost: 50,
    marketPrice: 55,
    marketValue: 5500,
    unrealizedPl: 500,
    unrealizedPlPercentage: 10,
    realizedPl: 200,
    totalPl: 700,
    lastUpdated: new Date('2024-01-01'),
  };

  const mockPositionMetrics = {
    totalQuantity: 100,
    averageCost: 50,
    marketValue: 5500,
    unrealizedPl: 500,
    realizedPl: 200,
    totalPl: 700,
    totalCost: 5000,
    unrealizedPlPercentage: 10,
  };

  beforeEach(async () => {
    const mockPortfolioAssetRepo = {
      find: jest.fn(),
      findOne: jest.fn(),
      save: jest.fn(),
    };

    const mockPositionManagerService = {
      calculatePositionMetrics: jest.fn(),
    };

    const mockTradeRepo = {
      findTradesByAssetAndPortfolio: jest.fn(),
      findTradesByDateRange: jest.fn(),
    };

    const mockTradeDetailRepo = {
      getRealizedPnlForTrade: jest.fn(),
      findDetailsByAssetAndPortfolio: jest.fn(),
      findDetailsByDateRange: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PositionService,
        {
          provide: getRepositoryToken(PortfolioAsset),
          useValue: mockPortfolioAssetRepo,
        },
        {
          provide: PositionManager,
          useValue: mockPositionManagerService,
        },
        {
          provide: TradeRepository,
          useValue: mockTradeRepo,
        },
        {
          provide: TradeDetailRepository,
          useValue: mockTradeDetailRepo,
        },
      ],
    }).compile();

    service = module.get<PositionService>(PositionService);
    mockPortfolioAssetRepository = module.get(getRepositoryToken(PortfolioAsset));
    mockPositionManager = module.get(PositionManager);
    mockTradeRepository = module.get(TradeRepository);
    mockTradeDetailRepository = module.get(TradeDetailRepository);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getCurrentPositions', () => {
    it('should return current positions for portfolio', async () => {
      const marketPrices = { 'asset-1': 55 };
      
      mockPortfolioAssetRepository.find.mockResolvedValue([mockPortfolioAsset]);
      mockTradeDetailRepository.getRealizedPnlForTrade.mockResolvedValue(200);

      const result = await service.getCurrentPositions('portfolio-1', marketPrices);

      expect(mockPortfolioAssetRepository.find).toHaveBeenCalledWith({
        where: { portfolioId: 'portfolio-1' },
        relations: ['asset'],
      });
      expect(mockTradeDetailRepository.getRealizedPnlForTrade).toHaveBeenCalledWith('asset-1');
      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        assetId: 'asset-1',
        assetSymbol: 'TEST',
        assetName: 'Test Asset',
        quantity: 100,
        avgCost: 50,
        marketPrice: 55,
        marketValue: 5500,
        unrealizedPl: 500,
        realizedPl: 200,
        totalPl: 700,
      });
    });

    it('should filter out zero quantity positions', async () => {
      const zeroQuantityAsset = { ...mockPortfolioAsset, quantity: 0 };
      
      mockPortfolioAssetRepository.find.mockResolvedValue([zeroQuantityAsset]);

      const result = await service.getCurrentPositions('portfolio-1');

      expect(result).toHaveLength(0);
    });

    it('should handle missing market prices', async () => {
      mockPortfolioAssetRepository.find.mockResolvedValue([mockPortfolioAsset]);
      mockTradeDetailRepository.getRealizedPnlForTrade.mockResolvedValue(0);

      const result = await service.getCurrentPositions('portfolio-1');

      expect(result[0].marketPrice).toBe(0);
      expect(result[0].marketValue).toBe(0);
    });
  });

  describe('getPositionByAsset', () => {
    it('should return position for specific asset', async () => {
      mockPortfolioAssetRepository.findOne.mockResolvedValue(mockPortfolioAsset);
      mockTradeDetailRepository.getRealizedPnlForTrade.mockResolvedValue(200);

      const result = await service.getPositionByAsset('portfolio-1', 'asset-1', 55);

      expect(mockPortfolioAssetRepository.findOne).toHaveBeenCalledWith({
        where: { portfolioId: 'portfolio-1', assetId: 'asset-1' },
        relations: ['asset'],
      });
      expect(result).toMatchObject({
        assetId: 'asset-1',
        assetSymbol: 'TEST',
        quantity: 100,
        marketPrice: 55,
      });
    });

    it('should return null when position not found', async () => {
      mockPortfolioAssetRepository.findOne.mockResolvedValue(null);

      const result = await service.getPositionByAsset('portfolio-1', 'nonexistent');

      expect(result).toBeNull();
    });

    it('should return null when quantity is zero', async () => {
      const zeroQuantityAsset = { ...mockPortfolioAsset, quantity: 0 };
      mockPortfolioAssetRepository.findOne.mockResolvedValue(zeroQuantityAsset);

      const result = await service.getPositionByAsset('portfolio-1', 'asset-1');

      expect(result).toBeNull();
    });
  });

  describe('updatePositionValue', () => {
    it('should update position value with market price', async () => {
      const updatedAsset = { ...mockPortfolioAsset, market_value: 5500, unrealized_pl: 500 };
      
      mockPortfolioAssetRepository.findOne.mockResolvedValue(mockPortfolioAsset);
      mockPortfolioAssetRepository.save.mockResolvedValue(updatedAsset);
      mockTradeDetailRepository.getRealizedPnlForTrade.mockResolvedValue(200);

      const result = await service.updatePositionValue('portfolio-1', 'asset-1', 55);

      expect(mockPortfolioAssetRepository.save).toHaveBeenCalledWith({
        ...mockPortfolioAsset,
        market_value: 5500,
        unrealized_pl: 500,
      });
      expect(result).toMatchObject({
        assetId: 'asset-1',
        marketPrice: 55,
        marketValue: 5500,
        unrealizedPl: 500,
      });
    });

    it('should throw error when position not found', async () => {
      mockPortfolioAssetRepository.findOne.mockResolvedValue(null);

      await expect(service.updatePositionValue('portfolio-1', 'nonexistent', 55))
        .rejects.toThrow(NotFoundException);
    });
  });

  describe('calculatePositionMetrics', () => {
    it('should calculate position metrics for asset', async () => {
      const mockTrades = [{} as Trade];
      const mockTradeDetails = [{} as TradeDetail];
      
      mockTradeRepository.findTradesByAssetAndPortfolio.mockResolvedValue(mockTrades);
      mockTradeDetailRepository.findDetailsByAssetAndPortfolio.mockResolvedValue(mockTradeDetails);
      mockPositionManager.calculatePositionMetrics.mockReturnValue(mockPositionMetrics);

      const result = await service.calculatePositionMetrics('portfolio-1', 'asset-1', 55);

      expect(mockTradeRepository.findTradesByAssetAndPortfolio).toHaveBeenCalledWith('asset-1', 'portfolio-1');
      expect(mockTradeDetailRepository.findDetailsByAssetAndPortfolio).toHaveBeenCalledWith('asset-1', 'portfolio-1');
      expect(mockPositionManager.calculatePositionMetrics).toHaveBeenCalledWith(
        'asset-1',
        mockTrades,
        55,
        mockTradeDetails,
      );
      expect(result).toEqual(mockPositionMetrics);
    });
  });

  describe('getPositionPerformance', () => {
    it('should get position performance over time', async () => {
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-31');
      const mockTrades = [{} as Trade];
      const mockTradeDetails = [{} as TradeDetail];
      
      mockTradeRepository.findTradesByDateRange.mockResolvedValue(mockTrades);
      mockTradeDetailRepository.findDetailsByDateRange.mockResolvedValue(mockTradeDetails);
      mockPositionManager.calculatePositionMetrics.mockReturnValue(mockPositionMetrics);

      const result = await service.getPositionPerformance('portfolio-1', 'asset-1', startDate, endDate);

      expect(mockTradeRepository.findTradesByDateRange).toHaveBeenCalledWith(
        startDate,
        endDate,
        'portfolio-1',
        'asset-1',
      );
      expect(mockTradeDetailRepository.findDetailsByDateRange).toHaveBeenCalledWith(
        startDate,
        endDate,
        'portfolio-1',
        'asset-1',
      );
      expect(result).toHaveLength(1);
    });
  });

  describe('getPortfolioPositionSummary', () => {
    it('should return portfolio position summary', async () => {
      const marketPrices = { 'asset-1': 55 };
      
      jest.spyOn(service, 'getCurrentPositions').mockResolvedValue([mockPositionSummary]);

      const result = await service.getPortfolioPositionSummary('portfolio-1', marketPrices);

      expect(result).toMatchObject({
        totalValue: 5500,
        totalCost: 5000,
        totalUnrealizedPl: 500,
        totalRealizedPl: 200,
        totalPl: 700,
        positionCount: 1,
        topPositions: [mockPositionSummary],
      });
    });
  });

  describe('updateAllPositionValues', () => {
    it('should update all positions with market prices', async () => {
      const marketPrices = { 'asset-1': 55 };
      const updatedAsset = { ...mockPortfolioAsset, market_value: 5500, unrealized_pl: 500 };
      
      mockPortfolioAssetRepository.find.mockResolvedValue([mockPortfolioAsset]);
      mockPortfolioAssetRepository.findOne.mockResolvedValue(mockPortfolioAsset);
      mockPortfolioAssetRepository.save.mockResolvedValue(updatedAsset);
      mockTradeDetailRepository.getRealizedPnlForTrade.mockResolvedValue(200);

      const result = await service.updateAllPositionValues('portfolio-1', marketPrices);

      expect(mockPortfolioAssetRepository.find).toHaveBeenCalledWith({
        where: { portfolioId: 'portfolio-1' },
        relations: ['asset'],
      });
      expect(result).toHaveLength(1);
    });
  });

  describe('getPositionAlerts', () => {
    it('should return position alerts', async () => {
      const lowQuantityPosition = { ...mockPositionSummary, quantity: 0.5 };
      const highLossPosition = { ...mockPositionSummary, unrealizedPlPercentage: -25 };
      const highGainPosition = { ...mockPositionSummary, unrealizedPlPercentage: 60 };
      
      jest.spyOn(service, 'getCurrentPositions').mockResolvedValue([
        lowQuantityPosition,
        highLossPosition,
        highGainPosition,
      ]);

      const result = await service.getPositionAlerts('portfolio-1');

      expect(result).toHaveLength(3);
      expect(result[0].alertType).toBe('LOW_QUANTITY');
      expect(result[1].alertType).toBe('HIGH_LOSS');
      expect(result[2].alertType).toBe('HIGH_GAIN');
    });

    it('should not return alerts for normal positions', async () => {
      const normalPosition = { ...mockPositionSummary, quantity: 100, unrealizedPlPercentage: 5 };
      
      jest.spyOn(service, 'getCurrentPositions').mockResolvedValue([normalPosition]);

      const result = await service.getPositionAlerts('portfolio-1');

      expect(result).toHaveLength(0);
    });
  });
});