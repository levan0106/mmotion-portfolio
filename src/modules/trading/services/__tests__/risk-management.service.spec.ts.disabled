import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { BadRequestException, NotFoundException } from '@nestjs/common';
import { RiskManagementService, SetRiskTargetsDto, UpdateRiskTargetsDto } from '../risk-management.service';
import { AssetTarget } from '../../entities/asset-target.entity';
import { PortfolioAsset } from '../../../portfolio/entities/portfolio-asset.entity';
import { RiskManager } from '../../managers/risk-manager';

describe('RiskManagementService', () => {
  let service: RiskManagementService;
  let mockAssetTargetRepository: jest.Mocked<Repository<AssetTarget>>;
  let mockPortfolioAssetRepository: jest.Mocked<Repository<PortfolioAsset>>;
  let mockRiskManager: jest.Mocked<RiskManager>;

  const mockAssetTarget: AssetTarget = {
    assetId: 'asset-1',
    stop_loss: 45,
    take_profit: 65,
    is_active: true,
    created_at: new Date('2024-01-01'),
    updated_at: new Date('2024-01-01'),
    has_stop_loss: true,
    has_take_profit: true,
    is_configured: true,
    asset: {
      id: 'asset-1',
      name: 'Test Asset',
      symbol: 'TEST',
      type: 'STOCK' as any,
      portfolioId: 'portfolio-1',
      created_at: new Date('2024-01-01'),
      updated_at: new Date('2024-01-01'),
      createdBy: 'user-1',
      updatedBy: 'user-1',
      initialValue: 1000,
      initialQuantity: 100,
      trades: [],
      portfolioAssets: [],
      getTotalValue: jest.fn().mockReturnValue(1000),
      getTotalQuantity: jest.fn().mockReturnValue(100),
      hasTrades: jest.fn().mockReturnValue(false),
      getDisplayName: jest.fn().mockReturnValue('Test Asset (TEST)'),
      toJSON: jest.fn().mockReturnValue({}),
    } as any,
  };

  const mockValidationResult = {
    isValid: true,
    errors: [],
  };

  beforeEach(async () => {
    const mockAssetTargetRepo = {
      findOne: jest.fn(),
      find: jest.fn(),
      save: jest.fn(),
      createQueryBuilder: jest.fn(),
    };

    const mockPortfolioAssetRepo = {
      find: jest.fn(),
    };

    const mockRiskManagerService = {
      validateRiskTargets: jest.fn(),
      updateRiskTargets: jest.fn(),
      setRiskTargets: jest.fn(),
      setStopLoss: jest.fn(),
      setTakeProfit: jest.fn(),
      getRiskTargets: jest.fn(),
      removeRiskTargets: jest.fn(),
      checkRiskTargets: jest.fn(),
      triggerRiskAlerts: jest.fn(),
      calculateRiskMetrics: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        RiskManagementService,
        {
          provide: getRepositoryToken(AssetTarget),
          useValue: mockAssetTargetRepo,
        },
        {
          provide: getRepositoryToken(PortfolioAsset),
          useValue: mockPortfolioAssetRepo,
        },
        {
          provide: RiskManager,
          useValue: mockRiskManagerService,
        },
      ],
    }).compile();

    service = module.get<RiskManagementService>(RiskManagementService);
    mockAssetTargetRepository = module.get(getRepositoryToken(AssetTarget));
    mockPortfolioAssetRepository = module.get(getRepositoryToken(PortfolioAsset));
    mockRiskManager = module.get(RiskManager);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('setRiskTargets', () => {
    it('should set risk targets for an asset', async () => {
      const setRiskTargetsDto: SetRiskTargetsDto = {
        assetId: 'asset-1',
        stopLoss: 45,
        takeProfit: 65,
        currentPrice: 50,
      };

      mockRiskManager.validateRiskTargets.mockReturnValue(mockValidationResult);
      mockAssetTargetRepository.findOne.mockResolvedValue(null);
      mockRiskManager.setRiskTargets.mockReturnValue(mockAssetTarget);
      mockAssetTargetRepository.save.mockResolvedValue(mockAssetTarget);

      const result = await service.setRiskTargets(setRiskTargetsDto);

      expect(mockRiskManager.validateRiskTargets).toHaveBeenCalledWith(
        'asset-1',
        45,
        65,
        50,
      );
      expect(mockRiskManager.setRiskTargets).toHaveBeenCalledWith('asset-1', 45, 65, 50);
      expect(mockAssetTargetRepository.save).toHaveBeenCalledWith(mockAssetTarget);
      expect(result).toEqual(mockAssetTarget);
    });

    it('should throw error when validation fails', async () => {
      const setRiskTargetsDto: SetRiskTargetsDto = {
        assetId: 'asset-1',
        stopLoss: 45,
        takeProfit: 65,
        currentPrice: 50,
      };

      const validationResult = {
        isValid: false,
        errors: ['Stop loss must be less than current price'],
      };

      mockRiskManager.validateRiskTargets.mockReturnValue(validationResult);

      await expect(service.setRiskTargets(setRiskTargetsDto))
        .rejects.toThrow(BadRequestException);
    });
  });

  describe('getRiskTargets', () => {
    it('should get risk targets for an asset', async () => {
  const mockRiskTargets = {
    assetId: 'asset-1',
    stopLoss: 45,
    takeProfit: 65,
    currentPrice: 50,
    isActive: true,
  };

      mockAssetTargetRepository.findOne.mockResolvedValue(mockAssetTarget);
      mockRiskManager.getRiskTargets.mockReturnValue(mockRiskTargets);

      const result = await service.getRiskTargets('asset-1');

      expect(mockAssetTargetRepository.findOne).toHaveBeenCalledWith({
        where: { assetId: 'asset-1' },
        relations: ['asset'],
      });
      expect(mockRiskManager.getRiskTargets).toHaveBeenCalledWith(mockAssetTarget);
      expect(result).toEqual(mockRiskTargets);
    });

    it('should return null when asset target not found', async () => {
      mockAssetTargetRepository.findOne.mockResolvedValue(null);

      const result = await service.getRiskTargets('nonexistent');

      expect(result).toBeNull();
    });
  });

  describe('updateRiskTargets', () => {
    it('should update risk targets for an asset', async () => {
      const updateRiskTargetsDto: UpdateRiskTargetsDto = {
        stopLoss: 40,
        takeProfit: 70,
        currentPrice: 50,
      };

      const updatedTarget = { ...mockAssetTarget, stop_loss: 40, take_profit: 70, has_stop_loss: true, has_take_profit: true, is_configured: true };

      mockAssetTargetRepository.findOne.mockResolvedValue(mockAssetTarget);
      mockRiskManager.updateRiskTargets.mockReturnValue(updatedTarget);
      mockAssetTargetRepository.save.mockResolvedValue(updatedTarget);

      const result = await service.updateRiskTargets('asset-1', updateRiskTargetsDto);

      expect(mockAssetTargetRepository.findOne).toHaveBeenCalledWith({
        where: { assetId: 'asset-1' },
      });
      expect(mockRiskManager.updateRiskTargets).toHaveBeenCalledWith(
        mockAssetTarget,
        40,
        70,
        50,
      );
      expect(result).toEqual(updatedTarget);
    });

    it('should throw error when asset target not found', async () => {
      const updateRiskTargetsDto: UpdateRiskTargetsDto = {
        stopLoss: 40,
        takeProfit: 70,
      };

      mockAssetTargetRepository.findOne.mockResolvedValue(null);

      await expect(service.updateRiskTargets('nonexistent', updateRiskTargetsDto))
        .rejects.toThrow(NotFoundException);
    });
  });

  describe('removeRiskTargets', () => {
    it('should remove risk targets for an asset', async () => {
      const deactivatedTarget = { ...mockAssetTarget, is_active: false, has_stop_loss: true, has_take_profit: true, is_configured: true };

      mockAssetTargetRepository.findOne.mockResolvedValue(mockAssetTarget);
      mockRiskManager.removeRiskTargets.mockReturnValue(deactivatedTarget);
      mockAssetTargetRepository.save.mockResolvedValue(deactivatedTarget);

      const result = await service.removeRiskTargets('asset-1');

      expect(mockRiskManager.removeRiskTargets).toHaveBeenCalledWith(mockAssetTarget);
      expect(result).toEqual(deactivatedTarget);
    });

    it('should throw error when asset target not found', async () => {
      mockAssetTargetRepository.findOne.mockResolvedValue(null);

      await expect(service.removeRiskTargets('nonexistent'))
        .rejects.toThrow(NotFoundException);
    });
  });

  describe('getAllActiveRiskTargets', () => {
    it('should get all active risk targets', async () => {
      const activeTargets = [mockAssetTarget];
      mockAssetTargetRepository.find.mockResolvedValue(activeTargets);

      const result = await service.getAllActiveRiskTargets();

      expect(mockAssetTargetRepository.find).toHaveBeenCalledWith({
        where: { is_active: true },
        relations: ['asset'],
        order: { updated_at: 'DESC' },
      });
      expect(result).toEqual(activeTargets);
    });
  });

  describe('validateRiskTargets', () => {
    it('should validate risk target settings', async () => {
      mockRiskManager.validateRiskTargets.mockReturnValue(mockValidationResult);

      const result = await service.validateRiskTargets('asset-1', 45, 65, 50);

      expect(mockRiskManager.validateRiskTargets).toHaveBeenCalledWith('asset-1', 45, 65, 50);
      expect(result).toEqual(mockValidationResult);
    });
  });
});