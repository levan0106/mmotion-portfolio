import { Test, TestingModule } from '@nestjs/testing';
import { BadRequestException, NotFoundException } from '@nestjs/common';
import { RiskManagementController, RiskMonitoringQueryDto, RiskAlertsHistoryQueryDto } from '../risk-management.controller';
import { RiskManagementService } from '../../services/risk-management.service';
import { SetRiskTargetsDto, UpdateRiskTargetsDto } from '../../dto/risk-target.dto';

describe('RiskManagementController', () => {
  let controller: RiskManagementController;
  let mockRiskManagementService: any;

  const mockAssetTarget = {
    id: 'target-1',
    assetId: 'asset-1',
    portfolioId: 'portfolio-1',
    stopLoss: 45,
    takeProfit: 65,
    isActive: true,
    created_at: new Date('2024-01-01'),
    updated_at: new Date('2024-01-01'),
  };

  const mockRiskSummary = {
    totalRiskTargets: 5,
    activeRiskTargets: 3,
    triggeredAlerts: 1,
    totalMaxLoss: 1000,
    totalMaxGain: 2000,
    averageRiskRewardRatio: 2.0,
    riskBreakdown: [],
  };

  const mockRiskStatistics = {
    totalTargets: 10,
    activeTargets: 7,
    stopLossOnly: 3,
    takeProfitOnly: 2,
    bothTargets: 2,
    averageStopLoss: 0.1,
    averageTakeProfit: 0.2,
  };

  beforeEach(async () => {
    mockRiskManagementService = {
      setRiskTargets: jest.fn(),
      getRiskTargets: jest.fn(),
      updateRiskTargets: jest.fn(),
      removeRiskTargets: jest.fn(),
      getAllActiveRiskTargets: jest.fn(),
      getPortfolioRiskTargets: jest.fn(),
      monitorRiskTargets: jest.fn(),
      getPortfolioRiskSummary: jest.fn(),
      getRiskAlertsHistory: jest.fn(),
      validateRiskTargets: jest.fn(),
      getRiskTargetStatistics: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      controllers: [RiskManagementController],
      providers: [
        {
          provide: RiskManagementService,
          useValue: mockRiskManagementService,
        },
      ],
    }).compile();

    controller = module.get<RiskManagementController>(RiskManagementController);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('setRiskTargets', () => {
    it('should set risk targets for an asset', async () => {
      const setRiskTargetsDto: SetRiskTargetsDto = {
        assetId: 'asset-1',
        currentPrice: 50,
        stopLoss: 45,
        takeProfit: 65,
      };

      mockRiskManagementService.setRiskTargets.mockResolvedValue(mockAssetTarget);

      const result = await controller.setRiskTargets('asset-1', setRiskTargetsDto);

      expect(mockRiskManagementService.setRiskTargets).toHaveBeenCalledWith({
        ...setRiskTargetsDto,
        assetId: 'asset-1',
      });
      expect(result).toEqual(mockAssetTarget);
    });

    it('should handle service errors', async () => {
      const setRiskTargetsDto: SetRiskTargetsDto = {
        assetId: 'asset-1',
        currentPrice: 50,
        stopLoss: 45,
        takeProfit: 65,
      };

      mockRiskManagementService.setRiskTargets.mockRejectedValue(new Error('Service error'));

      await expect(controller.setRiskTargets('asset-1', setRiskTargetsDto))
        .rejects.toThrow('Service error');
    });
  });

  describe('getRiskTargets', () => {
    it('should get risk targets for an asset', async () => {
      mockRiskManagementService.getRiskTargets.mockResolvedValue(mockAssetTarget);

      const result = await controller.getRiskTargets('asset-1');

      expect(mockRiskManagementService.getRiskTargets).toHaveBeenCalledWith('asset-1');
      expect(result).toEqual(mockAssetTarget);
    });

    it('should handle asset not found', async () => {
      mockRiskManagementService.getRiskTargets.mockRejectedValue(new NotFoundException('Asset not found'));

      await expect(controller.getRiskTargets('nonexistent'))
        .rejects.toThrow(NotFoundException);
    });
  });

  describe('updateRiskTargets', () => {
    it('should update risk targets for an asset', async () => {
      const updateRiskTargetsDto: UpdateRiskTargetsDto = {
        stopLoss: 40,
        takeProfit: 70,
      };

      const updatedTarget = { ...mockAssetTarget, ...updateRiskTargetsDto };
      mockRiskManagementService.updateRiskTargets.mockResolvedValue(updatedTarget);

      const result = await controller.updateRiskTargets('asset-1', updateRiskTargetsDto);

      expect(mockRiskManagementService.updateRiskTargets).toHaveBeenCalledWith('asset-1', updateRiskTargetsDto);
      expect(result).toEqual(updatedTarget);
    });
  });

  describe('removeRiskTargets', () => {
    it('should remove risk targets for an asset', async () => {
      mockRiskManagementService.removeRiskTargets.mockResolvedValue(undefined);

      await controller.removeRiskTargets('asset-1');

      expect(mockRiskManagementService.removeRiskTargets).toHaveBeenCalledWith('asset-1');
    });
  });

  describe('getAllActiveRiskTargets', () => {
    it('should get all active risk targets', async () => {
      const activeTargets = [mockAssetTarget];
      mockRiskManagementService.getAllActiveRiskTargets.mockResolvedValue(activeTargets);

      const result = await controller.getAllActiveRiskTargets();

      expect(mockRiskManagementService.getAllActiveRiskTargets).toHaveBeenCalled();
      expect(result).toEqual(activeTargets);
    });
  });

  describe('getPortfolioRiskTargets', () => {
    it('should get risk targets for a portfolio', async () => {
      const portfolioTargets = [mockAssetTarget];
      mockRiskManagementService.getPortfolioRiskTargets.mockResolvedValue(portfolioTargets);

      const result = await controller.getPortfolioRiskTargets('portfolio-1');

      expect(mockRiskManagementService.getPortfolioRiskTargets).toHaveBeenCalledWith('portfolio-1');
      expect(result).toEqual(portfolioTargets);
    });
  });

  describe('monitorRiskTargets', () => {
    it('should monitor risk targets and generate alerts', async () => {
      const query: RiskMonitoringQueryDto = {
        marketPrices: { 'asset-1': 50 },
      };

      const monitoringResult = {
        alerts: [],
        triggeredAlerts: [],
        riskMetrics: [],
      };

      mockRiskManagementService.monitorRiskTargets.mockResolvedValue(monitoringResult);

      const result = await controller.monitorRiskTargets(query);

      expect(mockRiskManagementService.monitorRiskTargets).toHaveBeenCalledWith(
        query.marketPrices,
        query.portfolioId,
      );
      expect(result).toEqual(monitoringResult);
    });

    it('should handle empty market prices', async () => {
      const query: RiskMonitoringQueryDto = {
        marketPrices: { 'asset-1': 50 },
      };

      const monitoringResult = {
        alerts: [],
        triggeredAlerts: [],
        riskMetrics: [],
      };

      mockRiskManagementService.monitorRiskTargets.mockResolvedValue(monitoringResult);

      const result = await controller.monitorRiskTargets(query);

      expect(mockRiskManagementService.monitorRiskTargets).toHaveBeenCalledWith({}, 'portfolio-1');
      expect(result).toEqual(monitoringResult);
    });
  });

  describe('getPortfolioRiskSummary', () => {
    it('should get risk summary for a portfolio', async () => {
      mockRiskManagementService.getPortfolioRiskSummary.mockResolvedValue(mockRiskSummary);

      const result = await controller.getPortfolioRiskSummary('portfolio-1');

      expect(mockRiskManagementService.getPortfolioRiskSummary).toHaveBeenCalledWith('portfolio-1', {});
      expect(result).toEqual(mockRiskSummary);
    });

    it('should handle market prices parameter', async () => {
      const marketPrices = { 'asset-1': 50 };
      mockRiskManagementService.getPortfolioRiskSummary.mockResolvedValue(mockRiskSummary);

      const result = await controller.getPortfolioRiskSummary('portfolio-1', JSON.stringify(marketPrices));

      expect(mockRiskManagementService.getPortfolioRiskSummary).toHaveBeenCalledWith('portfolio-1', marketPrices);
      expect(result).toEqual(mockRiskSummary);
    });

    it('should handle invalid market prices JSON', async () => {
      mockRiskManagementService.getPortfolioRiskSummary.mockResolvedValue(mockRiskSummary);

      const result = await controller.getPortfolioRiskSummary('portfolio-1', 'invalid-json');

      expect(mockRiskManagementService.getPortfolioRiskSummary).toHaveBeenCalledWith('portfolio-1', {});
      expect(result).toEqual(mockRiskSummary);
    });
  });

  describe('getRiskAlertsHistory', () => {
    it('should get risk alerts history', async () => {
      const query: RiskAlertsHistoryQueryDto = {
        assetId: 'asset-1',
        startDate: '2024-01-01',
        endDate: '2024-01-31',
      };

      const alertsHistory = [
        {
          assetId: 'asset-1',
          assetSymbol: 'TEST',
          alertType: 'STOP_LOSS',
          message: 'Stop loss triggered',
          timestamp: new Date('2024-01-15'),
          currentPrice: 45,
          targetPrice: 45,
        },
      ];

      mockRiskManagementService.getRiskAlertsHistory.mockResolvedValue(alertsHistory);

      const result = await controller.getRiskAlertsHistory(query);

      expect(mockRiskManagementService.getRiskAlertsHistory).toHaveBeenCalledWith(
        'asset-1',
        'portfolio-1',
        new Date('2024-01-01'),
        new Date('2024-01-31'),
      );
      expect(result).toEqual(alertsHistory);
    });
  });

  describe('validateRiskTargets', () => {
    it('should validate risk target settings', async () => {
      const validationResult = {
        isValid: true,
        errors: [],
      };

      mockRiskManagementService.validateRiskTargets.mockResolvedValue(validationResult);

      const result = await controller.validateRiskTargets('asset-1', 45, 65, 50);

      expect(mockRiskManagementService.validateRiskTargets).toHaveBeenCalledWith('asset-1', 45, 65, 50);
      expect(result).toEqual(validationResult);
    });

    it('should handle missing optional parameters', async () => {
      const validationResult = {
        isValid: false,
        errors: ['Stop loss is required'],
      };

      mockRiskManagementService.validateRiskTargets.mockResolvedValue(validationResult);

      const result = await controller.validateRiskTargets('asset-1', undefined, undefined, 50);

      expect(mockRiskManagementService.validateRiskTargets).toHaveBeenCalledWith('asset-1', null, null, 50);
      expect(result).toEqual(validationResult);
    });
  });

  describe('getRiskTargetStatistics', () => {
    it('should get risk target statistics', async () => {
      mockRiskManagementService.getRiskTargetStatistics.mockResolvedValue(mockRiskStatistics);

      const result = await controller.getRiskTargetStatistics();

      expect(mockRiskManagementService.getRiskTargetStatistics).toHaveBeenCalledWith(undefined);
      expect(result).toEqual(mockRiskStatistics);
    });

    it('should get risk target statistics for portfolio', async () => {
      mockRiskManagementService.getRiskTargetStatistics.mockResolvedValue(mockRiskStatistics);

      const result = await controller.getRiskTargetStatistics('portfolio-1');

      expect(mockRiskManagementService.getRiskTargetStatistics).toHaveBeenCalledWith('portfolio-1');
      expect(result).toEqual(mockRiskStatistics);
    });
  });

  describe('getRiskManagementDashboard', () => {
    it('should get risk management dashboard data', async () => {
      const dashboardData = {
        summary: mockRiskSummary,
        riskTargets: [mockAssetTarget],
        alerts: [],
        monitoring: { alerts: [], triggeredAlerts: [], riskMetrics: [] },
        statistics: mockRiskStatistics,
      };

      mockRiskManagementService.getPortfolioRiskSummary.mockResolvedValue(mockRiskSummary);
      mockRiskManagementService.getPortfolioRiskTargets.mockResolvedValue([mockAssetTarget]);
      mockRiskManagementService.monitorRiskTargets.mockResolvedValue({ alerts: [], triggeredAlerts: [], riskMetrics: [] });
      mockRiskManagementService.getRiskTargetStatistics.mockResolvedValue(mockRiskStatistics);

      const result = await controller.getRiskManagementDashboard('portfolio-1');

      expect(result).toEqual(dashboardData);
    });
  });
});