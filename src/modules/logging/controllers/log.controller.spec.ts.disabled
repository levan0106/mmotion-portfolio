import { Test, TestingModule } from '@nestjs/testing';
import { LogController } from './log.controller';
import { LogRepository } from '../repositories/log.repository';
import { LoggingService } from '../services/logging.service';
import { ContextManager } from '../services/context-manager.service';
import { LogSanitizationService } from '../services/log-sanitization.service';
import { LogLevel } from '../dto/create-log.dto';
import { CreateLogDto, CreatePerformanceLogDto } from '../dto/create-log.dto';
import { LogQueryDto } from '../dto/log-query.dto';
import { CleanupLogsDto, LogType, CleanupStrategy } from '../dto/cleanup-logs.dto';

describe('LogController', () => {
  let controller: LogController;
  let logRepository: LogRepository;
  let loggingService: LoggingService;
  let contextManager: ContextManager;
  let sanitizationService: LogSanitizationService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [LogController],
      providers: [
        {
          provide: LogRepository,
          useValue: {
            findApplicationLogs: jest.fn(),
            findRequestLogs: jest.fn(),
            findBusinessEventLogs: jest.fn(),
            findPerformanceLogs: jest.fn(),
            findLogs: jest.fn(),
            getLogStatistics: jest.fn(),
            cleanupOldLogs: jest.fn(),
          },
        },
        {
          provide: LoggingService,
          useValue: {
            info: jest.fn(),
            logBusinessEvent: jest.fn(),
            logPerformance: jest.fn(),
          },
        },
        {
          provide: ContextManager,
          useValue: {
            getCurrentContext: jest.fn(),
          },
        },
        {
          provide: LogSanitizationService,
          useValue: {
            sanitizeContext: jest.fn(),
            testSanitization: jest.fn(),
            getSanitizationStats: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<LogController>(LogController);
    logRepository = module.get<LogRepository>(LogRepository);
    loggingService = module.get<LoggingService>(LoggingService);
    contextManager = module.get<ContextManager>(ContextManager);
    sanitizationService = module.get<LogSanitizationService>(LogSanitizationService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createApplicationLog', () => {
    it('should create application log entry', async () => {
      const createLogDto: CreateLogDto = {
        level: LogLevel.INFO,
        message: 'Test log message',
        serviceName: 'test-service',
        moduleName: 'test-module',
        context: { userId: 'user-123' },
      };

      const mockContext = { requestId: 'req-123' };
      const mockSanitizedContext = { userId: 'user-123' };
      const mockResult = { id: 'log-123', message: 'Test log message' };

      jest.spyOn(contextManager, 'getCurrentContext').mockReturnValue(mockContext);
      jest.spyOn(sanitizationService, 'sanitizeContext').mockReturnValue(mockSanitizedContext);
      jest.spyOn(loggingService, 'info').mockResolvedValue(undefined);

      const result = await controller.createApplicationLog(createLogDto);

      expect(contextManager.getCurrentContext).toHaveBeenCalled();
      expect(sanitizationService.sanitizeContext).toHaveBeenCalledWith(createLogDto.context);
      expect(loggingService.info).toHaveBeenCalledWith(
        'Test log message',
        mockSanitizedContext,
        {
          serviceName: 'test-service',
          moduleName: 'test-module',
        },
      );
      expect(result).toBeUndefined();
    });
  });

  describe('createBusinessEventLog', () => {
    it('should create business event log entry', async () => {
      const createBusinessEventLogDto = {
        eventType: 'PORTFOLIO_CREATED',
        entityType: 'PORTFOLIO',
        entityId: 'portfolio-123',
        action: 'CREATE',
        oldValues: { name: 'Old Name' },
        newValues: { name: 'New Name' },
        metadata: { source: 'api' },
      };

      const mockContext = { userId: 'user-123' };
      const mockSanitizedOldValues = { name: 'Old Name' };
      const mockSanitizedNewValues = { name: 'New Name' };
      const mockSanitizedMetadata = { source: 'api' };
      const mockResult = { id: 'log-123', eventType: 'PORTFOLIO_CREATED' };

      jest.spyOn(contextManager, 'getCurrentContext').mockReturnValue(mockContext);
      jest.spyOn(sanitizationService, 'sanitizeContext')
        .mockReturnValueOnce(mockSanitizedOldValues)
        .mockReturnValueOnce(mockSanitizedNewValues)
        .mockReturnValueOnce(mockSanitizedMetadata);
      jest.spyOn(loggingService, 'logBusinessEvent').mockResolvedValue(undefined);

      const result = await controller.createBusinessEventLog(createBusinessEventLogDto);

      expect(contextManager.getCurrentContext).toHaveBeenCalled();
      expect(sanitizationService.sanitizeContext).toHaveBeenCalledTimes(3);
      expect(loggingService.logBusinessEvent).toHaveBeenCalledWith(
        'PORTFOLIO_CREATED',
        'PORTFOLIO',
        'portfolio-123',
        'CREATE',
        {
          oldValues: mockSanitizedOldValues,
          newValues: mockSanitizedNewValues,
          metadata: mockSanitizedMetadata,
          userId: 'user-123',
        },
      );
      expect(result).toBeUndefined();
    });
  });

  describe('createPerformanceLog', () => {
    it('should create performance log entry', async () => {
      const createPerformanceLogDto: CreatePerformanceLogDto = {
        operationName: 'portfolio_calculation',
        durationMs: '150',
        memoryUsageMb: '45.67',
        metadata: { portfolioId: 'portfolio-123' },
      };

      const mockContext = { userId: 'user-123' };
      const mockSanitizedMetadata = { portfolioId: 'portfolio-123' };
      const mockResult = { id: 'log-123', operationName: 'portfolio_calculation' };

      jest.spyOn(contextManager, 'getCurrentContext').mockReturnValue(mockContext);
      jest.spyOn(sanitizationService, 'sanitizeContext').mockReturnValue(mockSanitizedMetadata);
      jest.spyOn(loggingService, 'logPerformance').mockResolvedValue(undefined);

      const result = await controller.createPerformanceLog(createPerformanceLogDto);

      expect(contextManager.getCurrentContext).toHaveBeenCalled();
      expect(sanitizationService.sanitizeContext).toHaveBeenCalledWith(createPerformanceLogDto.metadata);
      expect(loggingService.logPerformance).toHaveBeenCalledWith(
        'portfolio_calculation',
        'CALCULATION',
        150,
        {
          memoryUsageMb: 45.67,
          cpuUsagePercent: undefined,
          databaseQueries: undefined,
          cacheHits: undefined,
          cacheMisses: undefined,
          externalApiCalls: undefined,
        },
        mockSanitizedMetadata,
      );
      expect(result).toBeUndefined();
    });
  });

  describe('getApplicationLogs', () => {
    it('should get application logs with filters', async () => {
      const query: LogQueryDto = {
        page: 1,
        limit: 10,
        level: LogLevel.ERROR,
        userId: 'user-123',
      };

      const mockResult = {
        data: [{ id: 'log-1', level: 'error' } as any],
        pagination: { page: 1, limit: 10, total: 1, totalPages: 1 },
      };

      jest.spyOn(logRepository, 'findApplicationLogs').mockResolvedValue(mockResult);

      const result = await controller.getApplicationLogs(query);

      expect(logRepository.findApplicationLogs).toHaveBeenCalledWith({
        page: 1,
        limit: 10,
        startDate: undefined,
        endDate: undefined,
        level: 'error',
        userId: 'user-123',
        serviceName: undefined,
        moduleName: undefined,
        requestId: undefined,
      });
      expect(result).toBe(mockResult);
    });

    it('should handle date filters', async () => {
      const query = {
        startDate: '2024-01-01T00:00:00Z',
        endDate: '2024-01-31T23:59:59Z',
      };

      const mockResult = {
        data: [],
        pagination: { page: 1, limit: 50, total: 0, totalPages: 0 },
      };

      jest.spyOn(logRepository, 'findApplicationLogs').mockResolvedValue(mockResult);

      await controller.getApplicationLogs(query);

      expect(logRepository.findApplicationLogs).toHaveBeenCalledWith({
        page: undefined,
        limit: undefined,
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-31T23:59:59Z'),
        level: undefined,
        userId: undefined,
        serviceName: undefined,
        moduleName: undefined,
        requestId: undefined,
      });
    });
  });

  describe('getRequestLogs', () => {
    it('should get request logs with filters', async () => {
      const query = {
        userId: 'user-123',
        responseStatus: 200,
      };

      const mockResult = {
        data: [{ id: 'log-1', responseStatus: 200 } as any],
        pagination: { page: 1, limit: 50, total: 1, totalPages: 1 },
      };

      jest.spyOn(logRepository, 'findRequestLogs').mockResolvedValue(mockResult);

      const result = await controller.getRequestLogs(query);

      expect(logRepository.findRequestLogs).toHaveBeenCalledWith({
        page: undefined,
        limit: undefined,
        startDate: undefined,
        endDate: undefined,
        userId: 'user-123',
        requestId: undefined,
        responseStatus: 200,
      });
      expect(result).toBe(mockResult);
    });
  });

  describe('getBusinessEventLogs', () => {
    it('should get business event logs with filters', async () => {
      const query: LogQueryDto = {
        page: 1,
        limit: 50,
      };

      const mockResult = {
        data: [{ id: 'log-1', eventType: 'PORTFOLIO_CREATED' } as any],
        pagination: { page: 1, limit: 50, total: 1, totalPages: 1 },
      };

      jest.spyOn(logRepository, 'findBusinessEventLogs').mockResolvedValue(mockResult);

      const result = await controller.getBusinessEventLogs(query);

      expect(logRepository.findBusinessEventLogs).toHaveBeenCalledWith({
        page: undefined,
        limit: undefined,
        startDate: undefined,
        endDate: undefined,
        userId: undefined,
        eventType: 'PORTFOLIO_CREATED',
        entityType: 'PORTFOLIO',
      });
      expect(result).toBe(mockResult);
    });
  });

  describe('getPerformanceLogs', () => {
    it('should get performance logs with filters', async () => {
      const query: LogQueryDto = {
        page: 1,
        limit: 50,
      };

      const mockResult = {
        data: [{ id: 'log-1', operationName: 'portfolio_calculation' } as any],
        pagination: { page: 1, limit: 50, total: 1, totalPages: 1 },
      };

      jest.spyOn(logRepository, 'findPerformanceLogs').mockResolvedValue(mockResult);

      const result = await controller.getPerformanceLogs(query);

      expect(logRepository.findPerformanceLogs).toHaveBeenCalledWith({
        page: undefined,
        limit: undefined,
        startDate: undefined,
        endDate: undefined,
        operationName: 'portfolio_calculation',
        operationType: undefined,
        minDuration: 100,
        maxDuration: 1000,
      });
      expect(result).toBe(mockResult);
    });
  });

  describe('getLogsByType', () => {
    it('should get logs by type', async () => {
      const type = 'application';
      const query: LogQueryDto = { level: LogLevel.ERROR };

      const mockResult = {
        data: [{ id: 'log-1', level: 'error' }],
        pagination: { page: 1, limit: 50, total: 1, totalPages: 1 },
      };

      jest.spyOn(logRepository, 'findLogs').mockResolvedValue(mockResult);

      const result = await controller.getLogsByType(type, query);

      expect(logRepository.findLogs).toHaveBeenCalledWith('application', {
        page: undefined,
        limit: undefined,
        startDate: undefined,
        endDate: undefined,
        level: 'error',
        userId: undefined,
        serviceName: undefined,
        moduleName: undefined,
        eventType: undefined,
        entityType: undefined,
        operationName: undefined,
        operationType: undefined,
        requestId: undefined,
        responseStatus: undefined,
        minDuration: undefined,
        maxDuration: undefined,
      });
      expect(result).toBe(mockResult);
    });
  });

  describe('getLogStatistics', () => {
    it('should get log statistics', async () => {
      const query = {
        startDate: '2024-01-01T00:00:00Z',
        endDate: '2024-01-31T23:59:59Z',
      };

      const mockResult = {
        totalLogs: 100,
        errorCount: 10,
        warningCount: 5,
        infoCount: 80,
        criticalCount: 5,
        averageResponseTime: 150,
        topErrors: [{ message: 'Error 1', count: 5 }],
        topOperations: [{ operation: 'test_op', count: 10, avgDuration: 100 }],
      };

      jest.spyOn(logRepository, 'getLogStatistics').mockResolvedValue(mockResult);

      const result = await controller.getLogStatistics(query);

      expect(logRepository.getLogStatistics).toHaveBeenCalledWith(
        new Date('2024-01-01T00:00:00Z'),
        new Date('2024-01-31T23:59:59Z'),
      );
      expect(result).toBe(mockResult);
    });
  });

  describe('getApplicationLogById', () => {
    it('should get application log by ID', async () => {
      const id = 'log-123';
      const result = await controller.getApplicationLogById(id);

      expect(result).toEqual({
        message: 'Get application log by ID not implemented yet',
        id: 'log-123',
      });
    });
  });

  describe('cleanupLogs', () => {
    it('should cleanup old logs', async () => {
      const cleanupLogsDto: CleanupLogsDto = {
        logType: LogType.ALL,
        strategy: CleanupStrategy.BY_AGE,
        cutoffDate: '2024-01-01T00:00:00.000Z',
      };
      const mockResult = {
        applicationLogsDeleted: 10,
        requestLogsDeleted: 5,
        businessEventLogsDeleted: 3,
        performanceLogsDeleted: 2,
      };

      jest.spyOn(logRepository, 'cleanupOldLogs').mockResolvedValue(mockResult);

      const result = await controller.cleanupLogs(cleanupLogsDto);

      expect(logRepository.cleanupOldLogs).toHaveBeenCalledWith(30);
      expect(result).toBe(mockResult);
    });

    it('should use default retention days if not provided', async () => {
      const cleanupLogsDto: CleanupLogsDto = {};
      const mockResult = {
        applicationLogsDeleted: 10,
        requestLogsDeleted: 5,
        businessEventLogsDeleted: 3,
        performanceLogsDeleted: 2,
      };

      jest.spyOn(logRepository, 'cleanupOldLogs').mockResolvedValue(mockResult);

      const result = await controller.cleanupLogs(cleanupLogsDto);

      expect(logRepository.cleanupOldLogs).toHaveBeenCalledWith(30);
      expect(result).toBe(mockResult);
    });
  });

  describe('testSanitization', () => {
    it('should test sanitization with sample data', async () => {
      const sampleData = { password: 'secret123', token: 'abc123' };
      const mockResult = { password: '[REDACTED]', token: '[REDACTED]' };

      jest.spyOn(sanitizationService, 'testSanitization').mockReturnValue(mockResult);

      const result = await controller.testSanitization(sampleData);

      expect(sanitizationService.testSanitization).toHaveBeenCalledWith(sampleData);
      expect(result).toBe(mockResult);
    });
  });

  describe('getSanitizationStats', () => {
    it('should get sanitization statistics', async () => {
      const inputData = { data: 'password=secret123 token=abc123' };
      const mockResult = {
        originalLength: 30,
        sanitizedLength: 35,
        redactionsCount: 2,
        patternsMatched: ['password', 'token'],
      };

      jest.spyOn(sanitizationService, 'getSanitizationStats').mockReturnValue(mockResult);

      const result = await controller.getSanitizationStats(inputData);

      expect(sanitizationService.getSanitizationStats).toHaveBeenCalledWith(inputData.data);
      expect(result).toBe(mockResult);
    });
  });
});
