import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository, Between } from 'typeorm';
import { LogRepository, LogFilterOptions } from './log.repository';
import { ApplicationLog } from '../entities/application-log.entity';
import { RequestLog } from '../entities/request-log.entity';
import { BusinessEventLog } from '../entities/business-event-log.entity';
import { PerformanceLog } from '../entities/performance-log.entity';

describe('LogRepository', () => {
  let repository: LogRepository;
  let applicationLogRepository: Repository<ApplicationLog>;
  let requestLogRepository: Repository<RequestLog>;
  let businessEventLogRepository: Repository<BusinessEventLog>;
  let performanceLogRepository: Repository<PerformanceLog>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        LogRepository,
        {
          provide: getRepositoryToken(ApplicationLog),
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
            findAndCount: jest.fn(),
            count: jest.fn(),
            createQueryBuilder: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(RequestLog),
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
            findAndCount: jest.fn(),
            count: jest.fn(),
            createQueryBuilder: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(BusinessEventLog),
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
            findAndCount: jest.fn(),
            count: jest.fn(),
            createQueryBuilder: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(PerformanceLog),
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
            findAndCount: jest.fn(),
            count: jest.fn(),
            createQueryBuilder: jest.fn(),
          },
        },
      ],
    }).compile();

    repository = module.get<LogRepository>(LogRepository);
    applicationLogRepository = module.get<Repository<ApplicationLog>>(
      getRepositoryToken(ApplicationLog),
    );
    requestLogRepository = module.get<Repository<RequestLog>>(
      getRepositoryToken(RequestLog),
    );
    businessEventLogRepository = module.get<Repository<BusinessEventLog>>(
      getRepositoryToken(BusinessEventLog),
    );
    performanceLogRepository = module.get<Repository<PerformanceLog>>(
      getRepositoryToken(PerformanceLog),
    );
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Store Methods', () => {
    it('should store application log', async () => {
      const logData = {
        level: 'error',
        message: 'Test error',
        service_name: 'test-service',
      };
      const mockLog = { id: 'log-123', ...logData };
      
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLog as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLog as any);

      const result = await repository.storeApplicationLog(logData);

      expect(applicationLogRepository.create).toHaveBeenCalledWith(logData);
      expect(applicationLogRepository.save).toHaveBeenCalledWith(mockLog);
      expect(result).toBe(mockLog);
    });

    it('should store request log', async () => {
      const logData = {
        request_id: 'req-123',
        method: 'GET',
        url: '/api/test',
      };
      const mockLog = { id: 'log-123', ...logData };
      
      jest.spyOn(requestLogRepository, 'create').mockReturnValue(mockLog as any);
      jest.spyOn(requestLogRepository, 'save').mockResolvedValue(mockLog as any);

      const result = await repository.storeRequestLog(logData);

      expect(requestLogRepository.create).toHaveBeenCalledWith(logData);
      expect(requestLogRepository.save).toHaveBeenCalledWith(mockLog);
      expect(result).toBe(mockLog);
    });

    it('should store business event log', async () => {
      const logData = {
        event_type: 'PORTFOLIO_CREATED',
        entity_type: 'PORTFOLIO',
        entity_id: 'portfolio-123',
        action: 'CREATE',
      };
      const mockLog = { id: 'log-123', ...logData };
      
      jest.spyOn(businessEventLogRepository, 'create').mockReturnValue(mockLog as any);
      jest.spyOn(businessEventLogRepository, 'save').mockResolvedValue(mockLog as any);

      const result = await repository.storeBusinessEventLog(logData);

      expect(businessEventLogRepository.create).toHaveBeenCalledWith(logData);
      expect(businessEventLogRepository.save).toHaveBeenCalledWith(mockLog);
      expect(result).toBe(mockLog);
    });

    it('should store performance log', async () => {
      const logData = {
        operation_name: 'test_operation',
        operation_type: 'CALCULATION',
        duration_ms: 100,
      };
      const mockLog = { id: 'log-123', ...logData };
      
      jest.spyOn(performanceLogRepository, 'create').mockReturnValue(mockLog as any);
      jest.spyOn(performanceLogRepository, 'save').mockResolvedValue(mockLog as any);

      const result = await repository.storePerformanceLog(logData);

      expect(performanceLogRepository.create).toHaveBeenCalledWith(logData);
      expect(performanceLogRepository.save).toHaveBeenCalledWith(mockLog);
      expect(result).toBe(mockLog);
    });
  });

  describe('Find Application Logs', () => {
    it('should find application logs with basic filters', async () => {
      const filters: LogFilterOptions = {
        page: 1,
        limit: 10,
        level: 'error',
        userId: 'user-123',
      };
      const mockLogs = [
        { id: 'log-1', level: 'error', user_id: 'user-123' } as ApplicationLog,
        { id: 'log-2', level: 'error', user_id: 'user-123' } as ApplicationLog,
      ];
      const mockResult: [ApplicationLog[], number] = [mockLogs, 2];

      jest.spyOn(applicationLogRepository, 'findAndCount').mockResolvedValue(mockResult);

      const result = await repository.findApplicationLogs(filters);

      expect(applicationLogRepository.findAndCount).toHaveBeenCalledWith({
        where: {
          level: 'error',
          user_id: 'user-123',
        },
        order: { timestamp: 'DESC' },
        skip: 0,
        take: 10,
      });
      expect(result.data).toBe(mockLogs);
      expect(result.pagination.total).toBe(2);
    });

    it('should find application logs with date range', async () => {
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-31');
      const filters: LogFilterOptions = {
        startDate,
        endDate,
      };
      const mockLogs = [{ id: 'log-1' } as ApplicationLog];
      const mockResult: [ApplicationLog[], number] = [mockLogs, 1];

      jest.spyOn(applicationLogRepository, 'findAndCount').mockResolvedValue(mockResult);

      await repository.findApplicationLogs(filters);

      expect(applicationLogRepository.findAndCount).toHaveBeenCalledWith({
        where: {
          timestamp: Between(startDate, endDate),
        },
        order: { timestamp: 'DESC' },
        skip: 0,
        take: 50,
      });
    });

    it('should find application logs with service and module filters', async () => {
      const filters: LogFilterOptions = {
        serviceName: 'portfolio-service',
        moduleName: 'portfolio',
        requestId: 'req-123',
      };
      const mockLogs = [{ id: 'log-1' } as ApplicationLog];
      const mockResult: [ApplicationLog[], number] = [mockLogs, 1];

      jest.spyOn(applicationLogRepository, 'findAndCount').mockResolvedValue(mockResult);

      await repository.findApplicationLogs(filters);

      expect(applicationLogRepository.findAndCount).toHaveBeenCalledWith({
        where: {
          service_name: 'portfolio-service',
          module_name: 'portfolio',
          request_id: 'req-123',
        },
        order: { timestamp: 'DESC' },
        skip: 0,
        take: 50,
      });
    });
  });

  describe('Find Request Logs', () => {
    it('should find request logs with filters', async () => {
      const filters: LogFilterOptions = {
        userId: 'user-123',
        responseStatus: 200,
      };
      const mockLogs = [{ id: 'log-1' } as RequestLog];
      const mockResult: [RequestLog[], number] = [mockLogs, 1];

      jest.spyOn(requestLogRepository, 'findAndCount').mockResolvedValue(mockResult);

      const result = await repository.findRequestLogs(filters);

      expect(requestLogRepository.findAndCount).toHaveBeenCalledWith({
        where: {
          user_id: 'user-123',
          response_status: 200,
        },
        order: { timestamp: 'DESC' },
        skip: 0,
        take: 50,
      });
      expect(result.data).toBe(mockLogs);
    });
  });

  describe('Find Business Event Logs', () => {
    it('should find business event logs with filters', async () => {
      const filters: LogFilterOptions = {
        eventType: 'PORTFOLIO_CREATED',
        entityType: 'PORTFOLIO',
        userId: 'user-123',
      };
      const mockLogs = [{ id: 'log-1' } as BusinessEventLog];
      const mockResult: [BusinessEventLog[], number] = [mockLogs, 1];

      jest.spyOn(businessEventLogRepository, 'findAndCount').mockResolvedValue(mockResult);

      const result = await repository.findBusinessEventLogs(filters);

      expect(businessEventLogRepository.findAndCount).toHaveBeenCalledWith({
        where: {
          event_type: 'PORTFOLIO_CREATED',
          entity_type: 'PORTFOLIO',
          user_id: 'user-123',
        },
        order: { timestamp: 'DESC' },
        skip: 0,
        take: 50,
      });
      expect(result.data).toBe(mockLogs);
    });
  });

  describe('Find Performance Logs', () => {
    it('should find performance logs with filters', async () => {
      const filters: LogFilterOptions = {
        operationName: 'portfolio_calculation',
        operationType: 'CALCULATION',
        minDuration: 100,
        maxDuration: 1000,
      };
      const mockLogs = [{ id: 'log-1' } as PerformanceLog];
      const mockResult: [PerformanceLog[], number] = [mockLogs, 1];

      jest.spyOn(performanceLogRepository, 'findAndCount').mockResolvedValue(mockResult);

      const result = await repository.findPerformanceLogs(filters);

      expect(performanceLogRepository.findAndCount).toHaveBeenCalledWith({
        where: {
          operation_name: expect.any(Object), // Like operator
          operation_type: 'CALCULATION',
          duration_ms: Between(100, 1000),
        },
        order: { timestamp: 'DESC' },
        skip: 0,
        take: 50,
      });
      expect(result.data).toBe(mockLogs);
    });
  });

  describe('Find Logs Generic Method', () => {
    it('should find application logs using generic method', async () => {
      const filters: LogFilterOptions = { level: 'error' };
      const mockLogs = [{ id: 'log-1' } as ApplicationLog];

      jest.spyOn(repository, 'findApplicationLogs').mockResolvedValue({
        data: mockLogs,
        pagination: { page: 1, limit: 50, total: 1, totalPages: 1 },
      });

      const result = await repository.findLogs('application', filters);

      expect(repository.findApplicationLogs).toHaveBeenCalledWith(filters);
      expect(result.data).toBe(mockLogs);
    });

    it('should find request logs using generic method', async () => {
      const filters: LogFilterOptions = { userId: 'user-123' };
      const mockLogs = [{ id: 'log-1' } as RequestLog];

      jest.spyOn(repository, 'findRequestLogs').mockResolvedValue({
        data: mockLogs,
        pagination: { page: 1, limit: 50, total: 1, totalPages: 1 },
      });

      const result = await repository.findLogs('request', filters);

      expect(repository.findRequestLogs).toHaveBeenCalledWith(filters);
      expect(result.data).toBe(mockLogs);
    });

    it('should find business event logs using generic method', async () => {
      const filters: LogFilterOptions = { eventType: 'PORTFOLIO_CREATED' };
      const mockLogs = [{ id: 'log-1' } as BusinessEventLog];

      jest.spyOn(repository, 'findBusinessEventLogs').mockResolvedValue({
        data: mockLogs,
        pagination: { page: 1, limit: 50, total: 1, totalPages: 1 },
      });

      const result = await repository.findLogs('business-event', filters);

      expect(repository.findBusinessEventLogs).toHaveBeenCalledWith(filters);
      expect(result.data).toBe(mockLogs);
    });

    it('should find performance logs using generic method', async () => {
      const filters: LogFilterOptions = { operationName: 'test_operation' };
      const mockLogs = [{ id: 'log-1' } as PerformanceLog];

      jest.spyOn(repository, 'findPerformanceLogs').mockResolvedValue({
        data: mockLogs,
        pagination: { page: 1, limit: 50, total: 1, totalPages: 1 },
      });

      const result = await repository.findLogs('performance', filters);

      expect(repository.findPerformanceLogs).toHaveBeenCalledWith(filters);
      expect(result.data).toBe(mockLogs);
    });

    it('should throw error for unsupported log type', async () => {
      await expect(repository.findLogs('invalid' as any, {})).rejects.toThrow('Unsupported log type: invalid');
    });
  });

  describe('Get Log Statistics', () => {
    it('should get log statistics', async () => {
      const startDate = new Date('2024-01-01');
      const endDate = new Date('2024-01-31');
      
      const mockQueryBuilder = {
        select: jest.fn().mockReturnThis(),
        addSelect: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        groupBy: jest.fn().mockReturnThis(),
        orderBy: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({ avgResponseTime: 150 }),
        getRawMany: jest.fn()
          .mockResolvedValueOnce([{ message: 'Error 1', count: '5' }])
          .mockResolvedValueOnce([{ operation: 'test_op', count: '10', avgDuration: 100 }]),
      };

      jest.spyOn(applicationLogRepository, 'count')
        .mockResolvedValueOnce(100) // totalLogs
        .mockResolvedValueOnce(10)  // errorCount
        .mockResolvedValueOnce(5)   // warningCount
        .mockResolvedValueOnce(80)  // infoCount
        .mockResolvedValueOnce(5);  // criticalCount

      jest.spyOn(requestLogRepository, 'createQueryBuilder').mockReturnValue(mockQueryBuilder as any);
      jest.spyOn(applicationLogRepository, 'createQueryBuilder').mockReturnValue(mockQueryBuilder as any);
      jest.spyOn(performanceLogRepository, 'createQueryBuilder').mockReturnValue(mockQueryBuilder as any);

      const result = await repository.getLogStatistics(startDate, endDate);

      expect(result).toEqual({
        totalLogs: 100,
        errorCount: 10,
        warningCount: 5,
        infoCount: 80,
        criticalCount: 5,
        averageResponseTime: 150,
        topErrors: [{ message: 'Error 1', count: 5 }],
        topOperations: [{ operation: 'test_op', count: 10, avgDuration: 100 }],
      });
    });
  });

  describe('Cleanup Old Logs', () => {
    it('should cleanup old logs', async () => {
      const mockQueryBuilder = {
        delete: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue({ affected: 10 }),
      };

      jest.spyOn(applicationLogRepository, 'createQueryBuilder').mockReturnValue(mockQueryBuilder as any);
      jest.spyOn(requestLogRepository, 'createQueryBuilder').mockReturnValue(mockQueryBuilder as any);
      jest.spyOn(businessEventLogRepository, 'createQueryBuilder').mockReturnValue(mockQueryBuilder as any);
      jest.spyOn(performanceLogRepository, 'createQueryBuilder').mockReturnValue(mockQueryBuilder as any);

      const result = await repository.cleanupOldLogs(30);

      expect(result).toEqual({
        applicationLogsDeleted: 10,
        requestLogsDeleted: 10,
        businessEventLogsDeleted: 10,
        performanceLogsDeleted: 10,
      });
    });
  });

  describe('Pagination', () => {
    it('should handle pagination correctly', async () => {
      const filters: LogFilterOptions = {
        page: 2,
        limit: 10,
      };
      const mockLogs = [{ id: 'log-1' } as ApplicationLog];
      const mockResult: [ApplicationLog[], number] = [mockLogs, 25];

      jest.spyOn(applicationLogRepository, 'findAndCount').mockResolvedValue(mockResult);

      const result = await repository.findApplicationLogs(filters);

      expect(applicationLogRepository.findAndCount).toHaveBeenCalledWith({
        where: {},
        order: { timestamp: 'DESC' },
        skip: 10, // (page - 1) * limit
        take: 10,
      });
      expect(result.pagination).toEqual({
        page: 2,
        limit: 10,
        total: 25,
        totalPages: 3, // Math.ceil(25 / 10)
      });
    });
  });
});
