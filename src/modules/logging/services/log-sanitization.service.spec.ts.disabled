import { LogSanitizationService, SanitizationConfig, SanitizationRule } from './log-sanitization.service';

describe('LogSanitizationService', () => {
  let service: LogSanitizationService;

  beforeEach(() => {
    service = new LogSanitizationService();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('String Sanitization', () => {
    it('should sanitize password patterns', () => {
      const input = 'password=secret123';
      const result = service.sanitizeString(input);
      expect(result).toBe('password=[REDACTED]');
    });

    it('should sanitize token patterns', () => {
      const input = 'token=abc123xyz';
      const result = service.sanitizeString(input);
      expect(result).toBe('token=[REDACTED]');
    });

    it('should sanitize API key patterns', () => {
      const input = 'api_key=sk-1234567890';
      const result = service.sanitizeString(input);
      expect(result).toBe('api_key=[REDACTED]');
    });

    it('should sanitize secret patterns', () => {
      const input = 'secret=mysecretkey';
      const result = service.sanitizeString(input);
      expect(result).toBe('secret=[REDACTED]');
    });

    it('should sanitize JWT tokens', () => {
      const input = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';
      const result = service.sanitizeString(input);
      expect(result).toBe('[REDACTED]');
    });

    it('should sanitize credit card numbers', () => {
      const input = 'Card: 4111-1111-1111-1111';
      const result = service.sanitizeString(input);
      expect(result).toBe('Card: [REDACTED]');
    });

    it('should sanitize SSN numbers', () => {
      const input = 'SSN: 123-45-6789';
      const result = service.sanitizeString(input);
      expect(result).toBe('SSN: [REDACTED]');
    });

    it('should sanitize phone numbers', () => {
      const input = 'Phone: +1-555-123-4567';
      const result = service.sanitizeString(input);
      expect(result).toBe('Phone: +[REDACTED]');
    });

    it('should sanitize IP addresses', () => {
      const input = 'IP: 192.168.1.1';
      const result = service.sanitizeString(input);
      expect(result).toBe('IP: [REDACTED]');
    });

    it('should sanitize MAC addresses', () => {
      const input = 'MAC: 00:1B:44:11:3A:B7';
      const result = service.sanitizeString(input);
      expect(result).toBe('MAC: [REDACTED]');
    });

    it('should handle case insensitive patterns', () => {
      const input = 'PASSWORD=secret123';
      const result = service.sanitizeString(input);
      expect(result).toBe('PASSWORD=[REDACTED]');
    });

    it('should handle multiple patterns in one string', () => {
      const input = 'password=secret123 token=abc123 4111-1111-1111-1111';
      const result = service.sanitizeString(input);
      expect(result).toBe('password=[REDACTED] token=[REDACTED] [REDACTED]');
    });

    it('should return original string if no patterns match', () => {
      const input = 'This is a normal string with no sensitive data';
      const result = service.sanitizeString(input);
      expect(result).toBe(input);
    });

    it('should handle null and undefined input', () => {
      expect(service.sanitizeString(null as any)).toBeNull();
      expect(service.sanitizeString(undefined as any)).toBeUndefined();
    });

    it('should handle non-string input', () => {
      expect(service.sanitizeString(123 as any)).toBe(123);
      expect(service.sanitizeString({} as any)).toEqual({});
    });
  });

  describe('Object Sanitization', () => {
    it('should sanitize object with sensitive keys', () => {
      const input = {
        username: 'john_doe',
        password: 'secret123',
        token: 'abc123',
        email: 'john@example.com',
      };
      const result = service.sanitizeObject(input);
      expect(result).toEqual({
        username: 'john_doe',
        password: '[REDACTED]',
        token: '[REDACTED]',
        email: 'john@example.com',
      });
    });

    it('should sanitize nested objects', () => {
      const input = {
        user: {
          name: 'John Doe',
          password: 'secret123',
          profile: {
            token: 'abc123',
            settings: 'normal_data',
          },
        },
      };
      const result = service.sanitizeObject(input);
      expect(result).toEqual({
        user: {
          name: 'John Doe',
          password: '[REDACTED]',
          profile: {
            token: '[REDACTED]',
            settings: 'normal_data',
          },
        },
      });
    });

    it('should sanitize arrays', () => {
      const input = [
        { password: 'secret1' },
        { password: 'secret2' },
        { normal: 'data' },
      ];
      const result = service.sanitizeObject(input);
      expect(result).toEqual([
        { password: '[REDACTED]' },
        { password: '[REDACTED]' },
        { normal: 'data' },
      ]);
    });

    it('should handle null and undefined values', () => {
      const input = {
        password: 'secret123',
        nullValue: null,
        undefinedValue: undefined,
        normalValue: 'data',
      };
      const result = service.sanitizeObject(input);
      expect(result).toEqual({
        password: '[REDACTED]',
        nullValue: null,
        undefinedValue: undefined,
        normalValue: 'data',
      });
    });

    it('should handle primitive values', () => {
      expect(service.sanitizeObject('password=secret123')).toBe('password=[REDACTED]');
      expect(service.sanitizeObject(123)).toBe(123);
      expect(service.sanitizeObject(true)).toBe(true);
      expect(service.sanitizeObject(null)).toBeNull();
      expect(service.sanitizeObject(undefined)).toBeUndefined();
    });
  });

  describe('Context Sanitization', () => {
    it('should sanitize context object', () => {
      const context = {
        requestId: 'req-123',
        userId: 'user-456',
        password: 'secret123',
        token: 'abc123',
        metadata: {
          apiKey: 'sk-1234567890',
          normalData: 'safe',
        },
      };
      const result = service.sanitizeContext(context);
      expect(result).toEqual({
        requestId: 'req-123',
        userId: 'user-456',
        password: '[REDACTED]',
        token: '[REDACTED]',
        metadata: {
          apiKey: '[REDACTED]',
          normalData: 'safe',
        },
      });
    });

    it('should handle empty context', () => {
      expect(service.sanitizeContext({})).toEqual({});
      expect(service.sanitizeContext(null as any)).toBeNull();
      expect(service.sanitizeContext(undefined as any)).toBeUndefined();
    });
  });

  describe('Sensitive Key Detection', () => {
    it('should identify sensitive keys', () => {
      const sensitiveKeys = [
        'password', 'passwd', 'pwd', 'secret', 'token', 'auth',
        'apiKey', 'api_key', 'secretKey', 'privateKey', 'accessToken',
        'sessionId', 'cookie', 'ssn', 'creditCard', 'cardNumber',
      ];

      sensitiveKeys.forEach(key => {
        expect(service['isSensitiveKey'](key)).toBe(true);
      });
    });

    it('should identify non-sensitive keys', () => {
      const nonSensitiveKeys = [
        'username', 'email', 'name', 'id', 'createdAt', 'updatedAt',
        'status', 'type', 'category', 'description', 'title',
      ];

      nonSensitiveKeys.forEach(key => {
        expect(service['isSensitiveKey'](key)).toBe(false);
      });
    });

    it('should handle case insensitive key detection', () => {
      expect(service['isSensitiveKey']('PASSWORD')).toBe(true);
      expect(service['isSensitiveKey']('API_KEY')).toBe(true);
      expect(service['isSensitiveKey']('Token')).toBe(true);
    });
  });

  describe('Custom Rules', () => {
    it('should apply custom sanitization rules', () => {
      const customRule: SanitizationRule = {
        pattern: /custom_pattern/g,
        replacement: '[CUSTOM_REDACTED]',
      };
      service.addCustomRule(customRule);

      const input = 'This contains custom_pattern data';
      const result = service.sanitizeString(input);
      expect(result).toBe('This contains [CUSTOM_REDACTED] data');
    });

    it('should create sanitization rules', () => {
      const rule = service.createRule('test_pattern', '[TEST_REDACTED]');
      expect(rule).toEqual({
        pattern: 'test_pattern',
        replacement: '[TEST_REDACTED]',
        caseSensitive: false,
      });
    });

    it('should remove custom rules', () => {
      const rule = service.createRule('test_pattern', '[TEST_REDACTED]');
      service.addCustomRule(rule);
      service.removeCustomRule('test_pattern');
      
      const input = 'This contains test_pattern data';
      const result = service.sanitizeString(input);
      expect(result).toBe(input); // Should not be sanitized
    });
  });

  describe('Configuration', () => {
    it('should get current configuration', () => {
      const config = service.getConfig();
      expect(config).toHaveProperty('enablePasswordMasking');
      expect(config).toHaveProperty('enableTokenRedaction');
      expect(config).toHaveProperty('redactionPlaceholder');
    });

    it('should update configuration', () => {
      service.updateConfig({
        enablePasswordMasking: false,
        redactionPlaceholder: '[MASKED]',
      });

      const config = service.getConfig();
      expect(config.enablePasswordMasking).toBe(false);
      expect(config.redactionPlaceholder).toBe('[MASKED]');
    });

    it('should create service with custom configuration', () => {
      const customConfig: SanitizationConfig = {
        enablePasswordMasking: false,
        enableTokenRedaction: true,
        redactionPlaceholder: '[MASKED]',
      };

      const customService = new LogSanitizationService(customConfig);
      const config = customService.getConfig();
      expect(config.enablePasswordMasking).toBe(false);
      expect(config.redactionPlaceholder).toBe('[MASKED]');
    });
  });

  describe('String Truncation', () => {
    it('should truncate long strings', () => {
      const longString = 'a'.repeat(15000);
      const result = service.sanitizeString(longString);
      expect(result).toContain('[TRUNCATED]');
      expect(result.length).toBeLessThan(15000);
    });

    it('should not truncate short strings', () => {
      const shortString = 'short string';
      const result = service.sanitizeString(shortString);
      expect(result).toBe(shortString);
    });
  });

  describe('Test Sanitization', () => {
    it('should test sanitization with sample data', () => {
      const sampleData = {
        password: 'secret123',
        token: 'abc123',
        normalData: 'safe',
      };

      const result = service.testSanitization(sampleData);
      expect(result).toEqual({
        password: '[REDACTED]',
        token: '[REDACTED]',
        normalData: 'safe',
      });
    });
  });

  describe('Sanitization Statistics', () => {
    it('should provide sanitization statistics', () => {
      const input = 'password=secret123 token=abc123 4111-1111-1111-1111';
      const stats = service.getSanitizationStats(input);

      expect(stats.originalLength).toBe(input.length);
      expect(stats.sanitizedLength).toBeGreaterThan(0);
      expect(stats.redactionsCount).toBeGreaterThan(0);
      expect(stats.patternsMatched).toContain('password');
      expect(stats.patternsMatched).toContain('token');
      expect(stats.patternsMatched).toContain('creditCard');
    });

    it('should handle empty input in statistics', () => {
      const stats = service.getSanitizationStats('');
      expect(stats.originalLength).toBe(0);
      expect(stats.sanitizedLength).toBe(0);
      expect(stats.redactionsCount).toBe(0);
      expect(stats.patternsMatched).toEqual([]);
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid regex patterns gracefully', () => {
      const invalidRule: SanitizationRule = {
        pattern: '[invalid-regex',
        replacement: '[REDACTED]',
      };
      service.addCustomRule(invalidRule);

      const input = 'test string';
      const result = service.sanitizeString(input);
      expect(result).toBe(input); // Should return original string
    });
  });

  describe('Email Masking', () => {
    it('should not mask emails by default', () => {
      const input = 'Email: john@example.com';
      const result = service.sanitizeString(input);
      expect(result).toBe(input); // Should not be masked
    });

    it('should mask emails when enabled', () => {
      service.updateConfig({ enableEmailMasking: true });
      const input = 'Email: john@example.com';
      const result = service.sanitizeString(input);
      expect(result).toBe('Email: [REDACTED]');
    });
  });
});
