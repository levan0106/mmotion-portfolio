import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { LogSummarizationService, LogSummaryOptions } from './log-summarization.service';
import { ApplicationLog } from '../entities/application-log.entity';
import { RequestLog } from '../entities/request-log.entity';
import { BusinessEventLog } from '../entities/business-event-log.entity';
import { PerformanceLog } from '../entities/performance-log.entity';

describe('LogSummarizationService', () => {
  let service: LogSummarizationService;
  let applicationLogRepository: jest.Mocked<Repository<ApplicationLog>>;
  let requestLogRepository: jest.Mocked<Repository<RequestLog>>;
  let businessEventLogRepository: jest.Mocked<Repository<BusinessEventLog>>;
  let performanceLogRepository: jest.Mocked<Repository<PerformanceLog>>;

  const mockApplicationLogs = [
    {
      id: '1',
      level: 'error',
      message: 'Database connection failed',
      module_name: 'DatabaseModule',
      user_id: 'user1',
      request_id: 'req1',
      created_at: new Date('2024-01-01T10:00:00Z'),
    },
    {
      id: '2',
      level: 'info',
      message: 'User login successful',
      module_name: 'AuthModule',
      user_id: 'user1',
      request_id: 'req2',
      created_at: new Date('2024-01-01T11:00:00Z'),
    },
    {
      id: '3',
      level: 'warn',
      message: 'Slow query detected',
      module_name: 'DatabaseModule',
      user_id: 'user2',
      request_id: 'req3',
      created_at: new Date('2024-01-01T12:00:00Z'),
    },
  ] as ApplicationLog[];

  const mockRequestLogs = [
    {
      id: '1',
      request_id: 'req1',
      method: 'GET',
      url: '/api/users',
      response_time_ms: 150,
      response_status: 200,
      created_at: new Date('2024-01-01T10:00:00Z'),
    },
    {
      id: '2',
      request_id: 'req2',
      method: 'POST',
      url: '/api/auth/login',
      response_time_ms: 300,
      response_status: 200,
      created_at: new Date('2024-01-01T11:00:00Z'),
    },
    {
      id: '3',
      request_id: 'req3',
      method: 'GET',
      url: '/api/portfolios',
      response_time_ms: 1200,
      response_status: 200,
      created_at: new Date('2024-01-01T12:00:00Z'),
    },
  ] as RequestLog[];

  const mockPerformanceLogs = [
    {
      id: '1',
      operation_name: 'getPortfolios',
      duration_ms: 150,
      memory_usage_mb: 128,
      cpu_usage_percent: 15,
      created_at: new Date('2024-01-01T10:00:00Z'),
    },
    {
      id: '2',
      operation_name: 'createTrade',
      duration_ms: 300,
      memory_usage_mb: 256,
      cpu_usage_percent: 25,
      created_at: new Date('2024-01-01T11:00:00Z'),
    },
  ] as PerformanceLog[];

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        LogSummarizationService,
        {
          provide: getRepositoryToken(ApplicationLog),
          useValue: {
            find: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(RequestLog),
          useValue: {
            find: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(BusinessEventLog),
          useValue: {
            find: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(PerformanceLog),
          useValue: {
            find: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<LogSummarizationService>(LogSummarizationService);
    applicationLogRepository = module.get(getRepositoryToken(ApplicationLog));
    requestLogRepository = module.get(getRepositoryToken(RequestLog));
    businessEventLogRepository = module.get(getRepositoryToken(BusinessEventLog));
    performanceLogRepository = module.get(getRepositoryToken(PerformanceLog));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('generateSummary', () => {
    it('should generate comprehensive log summary', async () => {
      const options: LogSummaryOptions = {
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
      };

      applicationLogRepository.find.mockResolvedValue(mockApplicationLogs);
      requestLogRepository.find.mockResolvedValue(mockRequestLogs);
      performanceLogRepository.find.mockResolvedValue(mockPerformanceLogs);

      const result = await service.generateSummary(options);

      expect(result).toHaveProperty('id');
      expect(result.period).toBe('2024-01-01 to 2024-01-01');
      expect(result.summaryType).toBe('daily');
      expect(result.totalLogs).toBe(3);
      expect(result.errorCount).toBe(1);
      expect(result.warningCount).toBe(1);
      expect(result.infoCount).toBe(1);
      expect(result.errorRate).toBeCloseTo(33.33, 1);
      expect(result.averageResponseTime).toBe(550);
      expect(result.uniqueUsers).toBe(2);
      expect(result.uniqueRequests).toBe(3);
      expect(result.topErrors).toHaveLength(1);
      expect(result.topModules).toHaveLength(2);
      expect(result.performanceMetrics).toBeDefined();
      expect(result.trends).toBeDefined();
      expect(result.insights).toHaveLength(0);
      expect(result.createdAt).toBeInstanceOf(Date);
      expect(result.updatedAt).toBeInstanceOf(Date);
    });

    it('should apply filters correctly', async () => {
      const options: LogSummaryOptions = {
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
        filters: {
          levels: ['error', 'warn'],
          modules: ['DatabaseModule'],
        },
      };

      const filteredLogs = mockApplicationLogs.filter(
        log => ['error', 'warn'].includes(log.level) && log.module_name === 'DatabaseModule'
      );

      applicationLogRepository.find.mockResolvedValue(filteredLogs);
      requestLogRepository.find.mockResolvedValue([]);
      performanceLogRepository.find.mockResolvedValue([]);

      const result = await service.generateSummary(options);

      expect(result.totalLogs).toBe(2);
      expect(result.errorCount).toBe(1);
      expect(result.warningCount).toBe(1);
      expect(result.infoCount).toBe(0);
    });

    it('should handle empty logs gracefully', async () => {
      const options: LogSummaryOptions = {
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
      };

      applicationLogRepository.find.mockResolvedValue([]);
      requestLogRepository.find.mockResolvedValue([]);
      performanceLogRepository.find.mockResolvedValue([]);

      const result = await service.generateSummary(options);

      expect(result.totalLogs).toBe(0);
      expect(result.errorRate).toBe(0);
      expect(result.averageResponseTime).toBe(0);
      expect(result.uniqueUsers).toBe(0);
      expect(result.uniqueRequests).toBe(0);
      expect(result.topErrors).toHaveLength(0);
      expect(result.topModules).toHaveLength(0);
    });

    it('should calculate top errors correctly', async () => {
      const options: LogSummaryOptions = {
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
      };

      const errorLogs = [
        ...mockApplicationLogs,
        { ...mockApplicationLogs[0], id: '4', level: 'error' },
        { ...mockApplicationLogs[0], id: '5', level: 'critical' },
      ] as ApplicationLog[];

      applicationLogRepository.find.mockResolvedValue(errorLogs);
      requestLogRepository.find.mockResolvedValue([]);
      performanceLogRepository.find.mockResolvedValue([]);

      const result = await service.generateSummary(options);

      expect(result.topErrors).toHaveLength(1);
      expect(result.topErrors[0].error).toBe('Database connection failed');
      expect(result.topErrors[0].count).toBe(3);
      expect(result.topErrors[0].percentage).toBeCloseTo(60, 1);
    });

    it('should calculate top modules correctly', async () => {
      const options: LogSummaryOptions = {
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
      };

      applicationLogRepository.find.mockResolvedValue(mockApplicationLogs);
      requestLogRepository.find.mockResolvedValue([]);
      performanceLogRepository.find.mockResolvedValue([]);

      const result = await service.generateSummary(options);

      expect(result.topModules).toHaveLength(2);
      expect(result.topModules[0].module).toBe('DatabaseModule');
      expect(result.topModules[0].count).toBe(2);
      expect(result.topModules[0].percentage).toBeCloseTo(66.67, 1);
      expect(result.topModules[1].module).toBe('AuthModule');
      expect(result.topModules[1].count).toBe(1);
      expect(result.topModules[1].percentage).toBeCloseTo(33.33, 1);
    });
  });

  describe('generateComparisonSummaries', () => {
    it('should generate comparison between two summaries', async () => {
      const currentOptions: LogSummaryOptions = {
        startDate: new Date('2024-01-02T00:00:00Z'),
        endDate: new Date('2024-01-02T23:59:59Z'),
        summaryType: 'daily',
      };

      const previousOptions: LogSummaryOptions = {
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
      };

      // Mock current period data (worse performance)
      const currentLogs = [
        ...mockApplicationLogs,
        { ...mockApplicationLogs[0], id: '4', level: 'error' },
        { ...mockApplicationLogs[0], id: '5', level: 'error' },
      ] as ApplicationLog[];

      const currentRequestLogs = [
        ...mockRequestLogs,
        { ...mockRequestLogs[0], id: '4', response_time_ms: 2000 },
      ] as RequestLog[];

      applicationLogRepository.find
        .mockResolvedValueOnce(currentLogs) // Current period
        .mockResolvedValueOnce(mockApplicationLogs); // Previous period

      requestLogRepository.find
        .mockResolvedValueOnce(currentRequestLogs) // Current period
        .mockResolvedValueOnce(mockRequestLogs); // Previous period

      performanceLogRepository.find
        .mockResolvedValueOnce(mockPerformanceLogs) // Current period
        .mockResolvedValueOnce(mockPerformanceLogs); // Previous period

      const result = await service.generateComparisonSummaries(currentOptions, previousOptions);

      expect(result).toHaveProperty('current');
      expect(result).toHaveProperty('previous');
      expect(result).toHaveProperty('changes');
      expect(result).toHaveProperty('insights');

      expect(result.changes.totalLogs.current).toBe(5);
      expect(result.changes.totalLogs.previous).toBe(3);
      expect(result.changes.totalLogs.change).toBe(2);
      expect(result.changes.totalLogs.percentage).toBeCloseTo(66.67, 1);

      expect(result.changes.errorRate.current).toBeCloseTo(60, 1);
      expect(result.changes.errorRate.previous).toBeCloseTo(33.33, 1);
      expect(result.changes.errorRate.change).toBeCloseTo(26.67, 1);

      expect(result.insights.length).toBeGreaterThan(0);
    });
  });

  describe('generateTrendAnalysis', () => {
    it('should generate trend analysis for multiple periods', async () => {
      const startDate = new Date('2024-01-01T00:00:00Z');
      const endDate = new Date('2024-01-03T23:59:59Z');

      // Mock data for 3 days
      applicationLogRepository.find
        .mockResolvedValueOnce(mockApplicationLogs) // Day 1
        .mockResolvedValueOnce([...mockApplicationLogs, { ...mockApplicationLogs[0], id: '4' }]) // Day 2
        .mockResolvedValueOnce([...mockApplicationLogs, { ...mockApplicationLogs[0], id: '5' }, { ...mockApplicationLogs[0], id: '6' }]); // Day 3

      requestLogRepository.find
        .mockResolvedValueOnce(mockRequestLogs) // Day 1
        .mockResolvedValueOnce(mockRequestLogs) // Day 2
        .mockResolvedValueOnce(mockRequestLogs); // Day 3

      performanceLogRepository.find
        .mockResolvedValueOnce(mockPerformanceLogs) // Day 1
        .mockResolvedValueOnce(mockPerformanceLogs) // Day 2
        .mockResolvedValueOnce(mockPerformanceLogs); // Day 3

      const result = await service.generateTrendAnalysis(startDate, endDate, 'day');

      expect(result).toHaveProperty('errorTrend');
      expect(result).toHaveProperty('performanceTrend');
      expect(result).toHaveProperty('userActivityTrend');
      expect(result).toHaveProperty('summaries');
      expect(result.summaries).toHaveLength(3);
    });
  });

  describe('generateInsights', () => {
    it('should generate high error rate insight', async () => {
      const summary = {
        id: 'test',
        period: '2024-01-01 to 2024-01-01',
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
        totalLogs: 100,
        errorCount: 15,
        warningCount: 10,
        infoCount: 70,
        debugCount: 5,
        criticalCount: 0,
        errorRate: 15,
        averageResponseTime: 500,
        uniqueUsers: 50,
        uniqueRequests: 100,
        topErrors: [],
        topModules: [],
        performanceMetrics: {
          slowestRequests: [],
          memoryUsage: { avg: 100, max: 200, min: 50 },
          cpuUsage: { avg: 30, max: 50, min: 10 },
        },
        trends: {
          errorTrend: 'stable' as const,
          performanceTrend: 'stable' as const,
          userActivityTrend: 'stable' as const,
        },
        insights: [],
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const insights = await service.generateInsights(summary);

      expect(insights).toHaveLength(1);
      expect(insights[0].type).toBe('error');
      expect(insights[0].message).toContain('Critical error rate: 15.00%');
      expect(insights[0].severity).toBe('high');
      expect(insights[0].recommendation).toContain('Investigate error patterns');
    });

    it('should generate performance insight', async () => {
      const summary = {
        id: 'test',
        period: '2024-01-01 to 2024-01-01',
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
        totalLogs: 100,
        errorCount: 2,
        warningCount: 5,
        infoCount: 90,
        debugCount: 3,
        criticalCount: 0,
        errorRate: 2,
        averageResponseTime: 2500,
        uniqueUsers: 50,
        uniqueRequests: 100,
        topErrors: [],
        topModules: [],
        performanceMetrics: {
          slowestRequests: [],
          memoryUsage: { avg: 100, max: 200, min: 50 },
          cpuUsage: { avg: 30, max: 50, min: 10 },
        },
        trends: {
          errorTrend: 'stable' as const,
          performanceTrend: 'stable' as const,
          userActivityTrend: 'stable' as const,
        },
        insights: [],
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const insights = await service.generateInsights(summary);

      expect(insights).toHaveLength(1);
      expect(insights[0].type).toBe('error');
      expect(insights[0].message).toContain('Critical performance issue: 2500.00ms');
      expect(insights[0].severity).toBe('high');
      expect(insights[0].recommendation).toContain('Optimize database queries');
    });

    it('should generate success insight for low error rate', async () => {
      const summary = {
        id: 'test',
        period: '2024-01-01 to 2024-01-01',
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
        totalLogs: 1000,
        errorCount: 2,
        warningCount: 10,
        infoCount: 980,
        debugCount: 8,
        criticalCount: 0,
        errorRate: 0.2,
        averageResponseTime: 200,
        uniqueUsers: 50,
        uniqueRequests: 100,
        topErrors: [],
        topModules: [],
        performanceMetrics: {
          slowestRequests: [],
          memoryUsage: { avg: 100, max: 200, min: 50 },
          cpuUsage: { avg: 30, max: 50, min: 10 },
        },
        trends: {
          errorTrend: 'stable' as const,
          performanceTrend: 'stable' as const,
          userActivityTrend: 'stable' as const,
        },
        insights: [],
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const insights = await service.generateInsights(summary);

      expect(insights).toHaveLength(1);
      expect(insights[0].type).toBe('success');
      expect(insights[0].message).toContain('Excellent error rate: 0.20%');
      expect(insights[0].severity).toBe('low');
      expect(insights[0].recommendation).toContain('Maintain current error handling');
    });

    it('should generate multiple insights for various issues', async () => {
      const summary = {
        id: 'test',
        period: '2024-01-01 to 2024-01-01',
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
        totalLogs: 100,
        errorCount: 8,
        warningCount: 10,
        infoCount: 80,
        debugCount: 2,
        criticalCount: 0,
        errorRate: 8,
        averageResponseTime: 1500,
        uniqueUsers: 1200,
        uniqueRequests: 100,
        topErrors: [],
        topModules: [],
        performanceMetrics: {
          slowestRequests: [],
          memoryUsage: { avg: 1200, max: 2000, min: 800 },
          cpuUsage: { avg: 85, max: 95, min: 70 },
        },
        trends: {
          errorTrend: 'stable' as const,
          performanceTrend: 'stable' as const,
          userActivityTrend: 'stable' as const,
        },
        insights: [],
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const insights = await service.generateInsights(summary);

      expect(insights.length).toBeGreaterThan(3);
      
      const errorInsight = insights.find(i => i.type === 'warning' && i.message.includes('High error rate'));
      expect(errorInsight).toBeDefined();
      
      const performanceInsight = insights.find(i => i.type === 'warning' && i.message.includes('Performance degradation'));
      expect(performanceInsight).toBeDefined();
      
      const memoryInsight = insights.find(i => i.type === 'warning' && i.message.includes('High memory usage'));
      expect(memoryInsight).toBeDefined();
      
      const cpuInsight = insights.find(i => i.type === 'warning' && i.message.includes('High CPU usage'));
      expect(cpuInsight).toBeDefined();
      
      const userInsight = insights.find(i => i.type === 'info' && i.message.includes('High user activity'));
      expect(userInsight).toBeDefined();
    });
  });

  describe('private methods', () => {
    it('should calculate performance metrics correctly', async () => {
      const options: LogSummaryOptions = {
        startDate: new Date('2024-01-01T00:00:00Z'),
        endDate: new Date('2024-01-01T23:59:59Z'),
        summaryType: 'daily',
      };

      applicationLogRepository.find.mockResolvedValue([]);
      requestLogRepository.find.mockResolvedValue(mockRequestLogs);
      performanceLogRepository.find.mockResolvedValue(mockPerformanceLogs);

      const result = await service.generateSummary(options);

      expect(result.performanceMetrics.slowestRequests).toHaveLength(3);
      expect(result.performanceMetrics.slowestRequests[0].endpoint).toBe('/api/portfolios');
      expect(result.performanceMetrics.slowestRequests[0].avgTime).toBe(1200);

      expect(result.performanceMetrics.memoryUsage.avg).toBe(192);
      expect(result.performanceMetrics.memoryUsage.max).toBe(256);
      expect(result.performanceMetrics.memoryUsage.min).toBe(128);

      expect(result.performanceMetrics.cpuUsage.avg).toBe(20);
      expect(result.performanceMetrics.cpuUsage.max).toBe(25);
      expect(result.performanceMetrics.cpuUsage.min).toBe(15);
    });
  });
});
