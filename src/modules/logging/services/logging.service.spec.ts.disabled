import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { LoggingService } from './logging.service';
import { ApplicationLog } from '../entities/application-log.entity';
import { RequestLog } from '../entities/request-log.entity';
import { BusinessEventLog } from '../entities/business-event-log.entity';
import { PerformanceLog } from '../entities/performance-log.entity';

describe('LoggingService', () => {
  let service: LoggingService;
  let applicationLogRepository: Repository<ApplicationLog>;
  let requestLogRepository: Repository<RequestLog>;
  let businessEventLogRepository: Repository<BusinessEventLog>;
  let performanceLogRepository: Repository<PerformanceLog>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        LoggingService,
        {
          provide: getRepositoryToken(ApplicationLog),
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(RequestLog),
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(BusinessEventLog),
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(PerformanceLog),
          useValue: {
            create: jest.fn(),
            save: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<LoggingService>(LoggingService);
    applicationLogRepository = module.get<Repository<ApplicationLog>>(
      getRepositoryToken(ApplicationLog),
    );
    requestLogRepository = module.get<Repository<RequestLog>>(
      getRepositoryToken(RequestLog),
    );
    businessEventLogRepository = module.get<Repository<BusinessEventLog>>(
      getRepositoryToken(BusinessEventLog),
    );
    performanceLogRepository = module.get<Repository<PerformanceLog>>(
      getRepositoryToken(PerformanceLog),
    );
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Error Logging', () => {
    it('should log error with message and context', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.error('Test error message', undefined, { userId: 'user-123' });

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          level: 'error',
          message: 'Test error message',
          context: { userId: 'user-123' },
          service_name: 'unknown',
        }),
      );
      expect(applicationLogRepository.save).toHaveBeenCalledWith(mockLogEntry);
    });

    it('should log error with Error object and stack trace', async () => {
      const error = new Error('Test error');
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.error('Test error message', error, { module: 'portfolio' });

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          level: 'error',
          message: 'Test error message',
          context: expect.objectContaining({
            error: {
              name: 'Error',
              message: 'Test error',
              stack: error.stack,
            },
            module: 'portfolio',
          }),
          stack_trace: error.stack,
        }),
      );
    });

    it('should log error with custom options', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      const options = {
        serviceName: 'portfolio-service',
        moduleName: 'portfolio',
        functionName: 'createPortfolio',
        errorCode: 'DB_CONNECTION_ERROR',
        userId: 'user-123',
        requestId: 'req-123',
      };

      await service.error('Database connection failed', undefined, {}, options);

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          level: 'error',
          message: 'Database connection failed',
          service_name: 'portfolio-service',
          module_name: 'portfolio',
          function_name: 'createPortfolio',
          error_code: 'DB_CONNECTION_ERROR',
          user_id: 'user-123',
          request_id: 'req-123',
        }),
      );
    });
  });

  describe('Critical Logging', () => {
    it('should log critical error with highest priority', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.critical('System failure', undefined, { component: 'database' });

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          level: 'critical',
          message: 'System failure',
          context: { component: 'database' },
        }),
      );
    });
  });

  describe('Info Logging', () => {
    it('should log info message', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.info('User logged in successfully', { userId: 'user-123' });

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          level: 'info',
          message: 'User logged in successfully',
          context: { userId: 'user-123' },
        }),
      );
    });
  });

  describe('Warning Logging', () => {
    it('should log warning message', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.warn('High memory usage detected', { memoryUsage: '85%' });

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          level: 'warn',
          message: 'High memory usage detected',
          context: { memoryUsage: '85%' },
        }),
      );
    });
  });

  describe('Debug Logging', () => {
    it('should log debug message', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.debug('Processing trade data', { tradeCount: 10 });

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          level: 'debug',
          message: 'Processing trade data',
          context: { tradeCount: 10 },
        }),
      );
    });
  });

  describe('Business Event Logging', () => {
    it('should log business event with old and new values', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(businessEventLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(businessEventLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      const oldValues = { name: 'Old Portfolio', value: 100000 };
      const newValues = { name: 'New Portfolio', value: 150000 };

      await service.logBusinessEvent(
        'PORTFOLIO_UPDATED',
        'PORTFOLIO',
        'portfolio-123',
        'UPDATE',
        oldValues,
        newValues,
        { userId: 'user-123' },
      );

      expect(businessEventLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          event_type: 'PORTFOLIO_UPDATED',
          entity_type: 'PORTFOLIO',
          entity_id: 'portfolio-123',
          action: 'UPDATE',
          old_values: oldValues,
          new_values: newValues,
          user_id: 'user-123',
        }),
      );
    });

    it('should log business event without old/new values', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(businessEventLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(businessEventLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.logBusinessEvent(
        'PORTFOLIO_CREATED',
        'PORTFOLIO',
        'portfolio-123',
        'CREATE',
        undefined,
        undefined,
        { userId: 'user-123' },
      );

      expect(businessEventLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          event_type: 'PORTFOLIO_CREATED',
          entity_type: 'PORTFOLIO',
          entity_id: 'portfolio-123',
          action: 'CREATE',
          old_values: undefined,
          new_values: undefined,
          user_id: 'user-123',
        }),
      );
    });
  });

  describe('Performance Logging', () => {
    it('should log performance metrics', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(performanceLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(performanceLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      const metrics = {
        memoryUsageMb: 45.67,
        cpuUsagePercent: 12.34,
        databaseQueries: 5,
        cacheHits: 3,
        cacheMisses: 2,
        externalApiCalls: 1,
      };

      await service.logPerformance(
        'portfolio_calculation',
        'CALCULATION',
        150,
        metrics,
        { metadata: { portfolioId: 'portfolio-123' } },
      );

      expect(performanceLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          operation_name: 'portfolio_calculation',
          operation_type: 'CALCULATION',
          duration_ms: 150,
          memory_usage_mb: 45.67,
          cpu_usage_percent: 12.34,
          database_queries: 5,
          cache_hits: 3,
          cache_misses: 2,
          external_api_calls: 1,
          metadata: { portfolioId: 'portfolio-123' },
        }),
      );
    });

    it('should log performance with minimal data', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(performanceLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(performanceLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.logPerformance('simple_operation', 'CALCULATION', 50);

      expect(performanceLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          operation_name: 'simple_operation',
          operation_type: 'CALCULATION',
          duration_ms: 50,
          memory_usage_mb: undefined,
          cpu_usage_percent: undefined,
          database_queries: undefined,
          cache_hits: undefined,
          cache_misses: undefined,
          external_api_calls: undefined,
          metadata: undefined,
        }),
      );
    });
  });

  describe('Request Logging', () => {
    it('should log HTTP request with all data', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(requestLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(requestLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      const headers = { 'Content-Type': 'application/json', 'Authorization': 'Bearer token' };
      const body = { name: 'Test Portfolio' };
      const queryParams = { page: '1', limit: '10' };

      await service.logRequest(
        'req-123',
        'POST',
        '/api/v1/portfolios',
        headers,
        body,
        queryParams,
        201,
        150,
        1024,
        { userId: 'user-123', ipAddress: '192.168.1.1', userAgent: 'Mozilla/5.0' },
      );

      expect(requestLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          request_id: 'req-123',
          method: 'POST',
          url: '/api/v1/portfolios',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
            'Authorization': '[REDACTED]',
          }),
          body: body,
          query_params: queryParams,
          response_status: 201,
          response_time_ms: 150,
          response_size_bytes: 1024,
          user_id: 'user-123',
          ip_address: '192.168.1.1',
          user_agent: 'Mozilla/5.0',
        }),
      );
    });

    it('should log HTTP request with minimal data', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(requestLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(requestLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      await service.logRequest('req-123', 'GET', '/api/v1/portfolios');

      expect(requestLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          request_id: 'req-123',
          method: 'GET',
          url: '/api/v1/portfolios',
          headers: undefined,
          body: undefined,
          query_params: undefined,
          response_status: undefined,
          response_time_ms: undefined,
          response_size_bytes: undefined,
          user_id: undefined,
          ip_address: undefined,
          user_agent: undefined,
        }),
      );
    });
  });

  describe('Context Sanitization', () => {
    it('should sanitize sensitive data in context', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      const context = {
        userId: 'user-123',
        password: 'secret123',
        token: 'jwt-token',
        creditCard: '4111-1111-1111-1111',
        normalData: 'safe data',
      };

      await service.info('Test message', context);

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          context: {
            userId: 'user-123',
            password: '[REDACTED]',
            token: '[REDACTED]',
            creditCard: '[REDACTED]',
            normalData: 'safe data',
          },
        }),
      );
    });

    it('should handle nested object sanitization', async () => {
      const mockLogEntry = { id: 'log-123' };
      jest.spyOn(applicationLogRepository, 'create').mockReturnValue(mockLogEntry as any);
      jest.spyOn(applicationLogRepository, 'save').mockResolvedValue(mockLogEntry as any);

      const context = {
        user: {
          id: 'user-123',
          password: 'secret123',
          profile: {
            name: 'John Doe',
            ssn: '123-45-6789',
          },
        },
        session: {
          token: 'session-token',
          data: 'normal data',
        },
      };

      await service.info('Test message', context);

      expect(applicationLogRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          context: {
            user: {
              id: 'user-123',
              password: '[REDACTED]',
              profile: {
                name: 'John Doe',
                ssn: '[REDACTED]',
              },
            },
            session: '[REDACTED]',
          },
        }),
      );
    });
  });

  describe('Error Handling', () => {
    it('should handle repository errors gracefully', async () => {
      jest.spyOn(applicationLogRepository, 'save').mockRejectedValue(new Error('Database error'));

      // Should not throw error
      await expect(service.error('Test error')).resolves.toBeUndefined();
    });

    it('should handle business event logging errors gracefully', async () => {
      jest.spyOn(businessEventLogRepository, 'save').mockRejectedValue(new Error('Database error'));

      // Should not throw error
      await expect(
        service.logBusinessEvent('TEST_EVENT', 'TEST', 'test-123', 'CREATE'),
      ).resolves.toBeUndefined();
    });

    it('should handle performance logging errors gracefully', async () => {
      jest.spyOn(performanceLogRepository, 'save').mockRejectedValue(new Error('Database error'));

      // Should not throw error
      await expect(service.logPerformance('test', 'CALCULATION', 100)).resolves.toBeUndefined();
    });

    it('should handle request logging errors gracefully', async () => {
      jest.spyOn(requestLogRepository, 'save').mockRejectedValue(new Error('Database error'));

      // Should not throw error
      await expect(service.logRequest('req-123', 'GET', '/test')).resolves.toBeUndefined();
    });
  });
});
