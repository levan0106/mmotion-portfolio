import { validate } from 'class-validator';
import { CreateLogDto, CreateBusinessEventLogDto, CreatePerformanceLogDto, LogLevel } from './create-log.dto';

describe('CreateLogDto', () => {
  let dto: CreateLogDto;

  beforeEach(() => {
    dto = new CreateLogDto();
  });

  describe('validation', () => {
    it('should pass validation with valid data', async () => {
      dto.level = LogLevel.ERROR;
      dto.message = 'User authentication failed';
      dto.serviceName = 'portfolio-service';
      dto.moduleName = 'authentication';
      dto.context = { userId: 'user-123', action: 'login' };

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should pass validation with minimal required data', async () => {
      dto.level = LogLevel.INFO;
      dto.message = 'Simple log message';

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation without required fields', async () => {
      const errors = await validate(dto);
      expect(errors).toHaveLength(2);
      expect(errors.map(e => e.property)).toContain('level');
      expect(errors.map(e => e.property)).toContain('message');
    });

    it('should fail validation with invalid log level', async () => {
      dto.level = 'invalid-level' as LogLevel;
      dto.message = 'Test message';

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('level');
    });

    it('should fail validation with empty message', async () => {
      dto.level = LogLevel.ERROR;
      dto.message = '';

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('message');
    });

    it('should fail validation with non-string message', async () => {
      dto.level = LogLevel.ERROR;
      dto.message = 123 as any;

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('message');
    });
  });
});

describe('CreateBusinessEventLogDto', () => {
  let dto: CreateBusinessEventLogDto;

  beforeEach(() => {
    dto = new CreateBusinessEventLogDto();
  });

  describe('validation', () => {
    it('should pass validation with valid data', async () => {
      dto.eventType = 'portfolio_created';
      dto.entityType = 'portfolio';
      dto.entityId = 'portfolio-123';
      dto.action = 'create';
      dto.oldValues = { name: 'Old Portfolio' };
      dto.newValues = { name: 'New Portfolio' };
      dto.metadata = { source: 'api', version: '1.0' };

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should pass validation with minimal required data', async () => {
      dto.eventType = 'portfolio_created';
      dto.entityType = 'portfolio';
      dto.entityId = 'portfolio-123';
      dto.action = 'create';

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation without required fields', async () => {
      const errors = await validate(dto);
      expect(errors).toHaveLength(4);
      expect(errors.map(e => e.property)).toContain('eventType');
      expect(errors.map(e => e.property)).toContain('entityType');
      expect(errors.map(e => e.property)).toContain('entityId');
      expect(errors.map(e => e.property)).toContain('action');
    });

    it('should fail validation with empty required fields', async () => {
      dto.eventType = '';
      dto.entityType = '';
      dto.entityId = '';
      dto.action = '';

      const errors = await validate(dto);
      expect(errors).toHaveLength(4);
      expect(errors.map(e => e.property)).toContain('eventType');
      expect(errors.map(e => e.property)).toContain('entityType');
      expect(errors.map(e => e.property)).toContain('entityId');
      expect(errors.map(e => e.property)).toContain('action');
    });
  });
});

describe('CreatePerformanceLogDto', () => {
  let dto: CreatePerformanceLogDto;

  beforeEach(() => {
    dto = new CreatePerformanceLogDto();
  });

  describe('validation', () => {
    it('should pass validation with valid data', async () => {
      dto.operationName = 'database_query';
      dto.durationMs = '150';
      dto.memoryUsageMb = '25.5';
      dto.cpuUsagePercent = '15.2';
      dto.metadata = { queryCount: 5, cacheHits: 3 };

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should pass validation with minimal required data', async () => {
      dto.operationName = 'database_query';
      dto.durationMs = '150';

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation without required fields', async () => {
      const errors = await validate(dto);
      expect(errors).toHaveLength(2);
      expect(errors.map(e => e.property)).toContain('operationName');
      expect(errors.map(e => e.property)).toContain('durationMs');
    });

    it('should fail validation with empty required fields', async () => {
      dto.operationName = '';
      dto.durationMs = '';

      const errors = await validate(dto);
      expect(errors).toHaveLength(2);
      expect(errors.map(e => e.property)).toContain('operationName');
      expect(errors.map(e => e.property)).toContain('durationMs');
    });

    it('should fail validation with non-string values', async () => {
      dto.operationName = 123 as any;
      dto.durationMs = 150 as any;

      const errors = await validate(dto);
      expect(errors).toHaveLength(2);
      expect(errors.map(e => e.property)).toContain('operationName');
      expect(errors.map(e => e.property)).toContain('durationMs');
    });
  });
});
