import { validate } from 'class-validator';
import { CleanupLogsDto, LogType, CleanupStrategy } from './cleanup-logs.dto';

describe('CleanupLogsDto', () => {
  let dto: CleanupLogsDto;

  beforeEach(() => {
    dto = new CleanupLogsDto();
  });

  describe('validation', () => {
    it('should pass validation with valid data', async () => {
      dto.logType = LogType.APPLICATION;
      dto.strategy = CleanupStrategy.BY_AGE;
      dto.cutoffDate = '2024-01-01T00:00:00.000Z';
      dto.maxLogs = 10000;
      dto.maxSizeMb = 1000;
      dto.dryRun = true;
      dto.logLevel = 'debug';
      dto.serviceName = 'portfolio-service';

      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should pass validation with minimal data', async () => {
      const errors = await validate(dto);
      expect(errors).toHaveLength(0);
    });

    it('should fail validation with invalid log type', async () => {
      dto.logType = 'invalid-type' as LogType;

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('logType');
    });

    it('should fail validation with invalid strategy', async () => {
      dto.strategy = 'invalid-strategy' as CleanupStrategy;

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('strategy');
    });

    it('should fail validation with invalid date format', async () => {
      dto.cutoffDate = 'invalid-date';

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('cutoffDate');
    });

    it('should fail validation with invalid maxLogs', async () => {
      dto.maxLogs = 0;

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('maxLogs');
    });

    it('should fail validation with invalid maxSizeMb', async () => {
      dto.maxSizeMb = 0;

      const errors = await validate(dto);
      expect(errors).toHaveLength(1);
      expect(errors[0].property).toBe('maxSizeMb');
    });

    it('should fail validation with non-number values for numeric fields', async () => {
      dto.maxLogs = 'invalid' as any;
      dto.maxSizeMb = 'invalid' as any;

      const errors = await validate(dto);
      expect(errors).toHaveLength(2);
      expect(errors.map(e => e.property)).toContain('maxLogs');
      expect(errors.map(e => e.property)).toContain('maxSizeMb');
    });
  });

  describe('default values', () => {
    it('should have correct default values', () => {
      expect(dto.logType).toBe(LogType.ALL);
      expect(dto.strategy).toBe(CleanupStrategy.BY_AGE);
      expect(dto.dryRun).toBe(false);
    });
  });
});
