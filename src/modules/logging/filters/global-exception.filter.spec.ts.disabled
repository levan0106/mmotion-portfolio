import { Test, TestingModule } from '@nestjs/testing';
import { HttpException, HttpStatus } from '@nestjs/common';
import { ArgumentsHost } from '@nestjs/common';
import { Request, Response } from 'express';
import { GlobalExceptionFilter } from './global-exception.filter';
import { LoggingService } from '../services/logging.service';
import { ContextManager } from '../services/context-manager.service';
import { LogSanitizationService } from '../services/log-sanitization.service';

describe('GlobalExceptionFilter', () => {
  let filter: GlobalExceptionFilter;
  let loggingService: jest.Mocked<LoggingService>;
  let contextManager: jest.Mocked<ContextManager>;
  let sanitizationService: jest.Mocked<LogSanitizationService>;
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let mockArgumentsHost: ArgumentsHost;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        GlobalExceptionFilter,
        {
          provide: LoggingService,
          useValue: {
            error: jest.fn(),
            warn: jest.fn(),
            info: jest.fn(),
          },
        },
        {
          provide: ContextManager,
          useValue: {
            getCurrentContext: jest.fn(),
          },
        },
        {
          provide: LogSanitizationService,
          useValue: {
            sanitizeContext: jest.fn(),
          },
        },
      ],
    }).compile();

    filter = module.get<GlobalExceptionFilter>(GlobalExceptionFilter);
    loggingService = module.get(LoggingService);
    contextManager = module.get(ContextManager);
    sanitizationService = module.get(LogSanitizationService);

    // Setup mock request
    mockRequest = {
      method: 'GET',
      url: '/api/test',
      headers: {
        'user-agent': 'test-agent',
        'x-forwarded-for': '192.168.1.1',
      },
      connection: {
        remoteAddress: '192.168.1.1',
      } as any,
      socket: {
        remoteAddress: '192.168.1.1',
      } as any,
    };

    // Setup mock response
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    // Setup mock arguments host
    mockArgumentsHost = {
      switchToHttp: jest.fn().mockReturnValue({
        getRequest: () => mockRequest,
        getResponse: () => mockResponse,
      }),
    } as any;

    // Setup default context
    contextManager.getCurrentContext.mockReturnValue({
      requestId: 'test-request-id',
      userId: 'test-user-id',
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('catch', () => {
    it('should handle HttpException with string response', () => {
      const exception = new HttpException('Test error', HttpStatus.BAD_REQUEST);
      sanitizationService.sanitizeContext.mockReturnValue({
        requestId: 'test-request-id',
        userId: 'test-user-id',
        method: 'GET',
        url: '/api/test',
        statusCode: 400,
        errorName: 'HttpException',
        errorMessage: 'Test error',
      });

      filter.catch(exception, mockArgumentsHost);

      expect(loggingService.error).toHaveBeenCalledWith(
        'Unhandled exception: HttpException',
        expect.objectContaining({
          requestId: 'test-request-id',
          userId: 'test-user-id',
          method: 'GET',
          url: '/api/test',
          statusCode: 400,
          errorName: 'HttpException',
          errorMessage: 'Test error',
        }),
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        statusCode: 400,
        message: 'Test error',
        error: 'HttpException',
        requestId: 'test-request-id',
        timestamp: expect.any(String),
      });
    });

    it('should handle HttpException with object response', () => {
      const exception = new HttpException(
        { message: 'Validation failed', errors: ['field1 is required'] },
        HttpStatus.UNPROCESSABLE_ENTITY,
      );
      sanitizationService.sanitizeContext.mockReturnValue({
        requestId: 'test-request-id',
        userId: 'test-user-id',
        method: 'POST',
        url: '/api/validate',
        statusCode: 422,
        errorName: 'HttpException',
        errorMessage: 'Validation failed',
      });

      filter.catch(exception, mockArgumentsHost);

      expect(loggingService.error).toHaveBeenCalledWith(
        'Unhandled exception: HttpException',
        expect.objectContaining({
          statusCode: 422,
          errorName: 'HttpException',
          errorMessage: 'Validation failed',
        }),
      );

      expect(mockResponse.status).toHaveBeenCalledWith(422);
      expect(mockResponse.json).toHaveBeenCalledWith({
        statusCode: 422,
        message: 'Validation failed',
        error: 'HttpException',
        requestId: 'test-request-id',
        timestamp: expect.any(String),
      });
    });

    it('should handle non-HTTP exceptions', () => {
      const exception = new Error('Database connection failed');
      sanitizationService.sanitizeContext.mockReturnValue({
        requestId: 'test-request-id',
        userId: 'test-user-id',
        method: 'GET',
        url: '/api/test',
        statusCode: 500,
        errorName: 'Error',
        errorMessage: 'Database connection failed',
        stackTrace: expect.any(String),
      });

      filter.catch(exception, mockArgumentsHost);

      expect(loggingService.error).toHaveBeenCalledWith(
        'Unhandled exception: Error',
        expect.objectContaining({
          statusCode: 500,
          errorName: 'Error',
          errorMessage: 'Database connection failed',
          stackTrace: expect.any(String),
        }),
      );

      expect(mockResponse.status).toHaveBeenCalledWith(500);
      expect(mockResponse.json).toHaveBeenCalledWith({
        statusCode: 500,
        message: 'Database connection failed',
        error: 'Error',
        requestId: 'test-request-id',
        timestamp: expect.any(String),
      });
    });

    it('should handle unknown exceptions', () => {
      const exception = 'String error';
      sanitizationService.sanitizeContext.mockReturnValue({
        requestId: 'test-request-id',
        userId: 'test-user-id',
        method: 'GET',
        url: '/api/test',
        statusCode: 500,
        errorName: 'UnknownError',
        errorMessage: 'Internal server error',
      });

      filter.catch(exception, mockArgumentsHost);

      expect(loggingService.error).toHaveBeenCalledWith(
        'Unhandled exception: UnknownError',
        expect.objectContaining({
          statusCode: 500,
          errorName: 'UnknownError',
          errorMessage: 'Internal server error',
        }),
      );

      expect(mockResponse.status).toHaveBeenCalledWith(500);
      expect(mockResponse.json).toHaveBeenCalledWith({
        statusCode: 500,
        message: 'Internal server error',
        error: 'UnknownError',
        requestId: 'test-request-id',
        timestamp: expect.any(String),
      });
    });

    it('should use anonymous user when no context available', () => {
      contextManager.getCurrentContext.mockReturnValue(null);
      const exception = new HttpException('Test error', HttpStatus.BAD_REQUEST);
      sanitizationService.sanitizeContext.mockReturnValue({
        requestId: 'unknown',
        userId: 'anonymous',
        method: 'GET',
        url: '/api/test',
        statusCode: 400,
        errorName: 'BadRequestException',
        errorMessage: 'Test error',
      });

      filter.catch(exception, mockArgumentsHost);

      expect(loggingService.error).toHaveBeenCalledWith(
        'Unhandled exception: BadRequestException',
        expect.objectContaining({
          requestId: 'unknown',
          userId: 'anonymous',
        }),
      );
    });

    it('should log with appropriate severity levels', () => {
      const testCases = [
        { status: 400, expectedMethod: 'error' as const },
        { status: 404, expectedMethod: 'error' as const },
        { status: 422, expectedMethod: 'error' as const },
        { status: 500, expectedMethod: 'error' as const },
        { status: 503, expectedMethod: 'error' as const },
      ];

      testCases.forEach(({ status, expectedMethod }) => {
        const exception = new HttpException('Test error', status);
        sanitizationService.sanitizeContext.mockReturnValue({
          requestId: 'test-request-id',
          userId: 'test-user-id',
          method: 'GET',
          url: '/api/test',
          statusCode: status,
          errorName: 'HttpException',
          errorMessage: 'Test error',
        });

        filter.catch(exception, mockArgumentsHost);

        expect(loggingService[expectedMethod]).toHaveBeenCalledWith(
          'Unhandled exception: HttpException',
          expect.objectContaining({
            statusCode: status,
          }),
        );
      });
    });

    it('should extract client IP from various headers', () => {
      const testCases = [
        {
          headers: { 'x-forwarded-for': '192.168.1.1, 10.0.0.1' },
          expectedIp: '192.168.1.1',
        },
        {
          headers: { 'x-real-ip': '192.168.1.2' },
          expectedIp: '192.168.1.2',
        },
        {
          headers: {},
          connection: { remoteAddress: '192.168.1.3' },
          expectedIp: '192.168.1.3',
        },
        {
          headers: {},
          socket: { remoteAddress: '192.168.1.4' },
          expectedIp: '192.168.1.4',
        },
      ];

      testCases.forEach(({ headers, connection, socket, expectedIp }) => {
        mockRequest = {
          method: 'GET',
          url: '/api/test',
          headers,
          connection: connection as any,
          socket: socket as any,
        };

        mockArgumentsHost = {
          switchToHttp: jest.fn().mockReturnValue({
            getRequest: () => mockRequest,
            getResponse: () => mockResponse,
          }),
        } as any;

        const exception = new HttpException('Test error', HttpStatus.BAD_REQUEST);
        sanitizationService.sanitizeContext.mockReturnValue({
          requestId: 'test-request-id',
          userId: 'test-user-id',
          method: 'GET',
          url: '/api/test',
          ipAddress: expectedIp,
          statusCode: 400,
          errorName: 'BadRequestException',
          errorMessage: 'Test error',
        });

        filter.catch(exception, mockArgumentsHost);

        expect(sanitizationService.sanitizeContext).toHaveBeenCalledWith(
          expect.objectContaining({
            ipAddress: expectedIp,
          }),
        );
      });
    });

    it('should sanitize error context', () => {
      const exception = new HttpException('Test error', HttpStatus.BAD_REQUEST);
      const sanitizedContext = {
        requestId: 'test-request-id',
        userId: 'test-user-id',
        method: 'GET',
        url: '/api/test',
        statusCode: 400,
        errorName: 'HttpException',
        errorMessage: 'Test error',
      };

      sanitizationService.sanitizeContext.mockReturnValue(sanitizedContext);

      filter.catch(exception, mockArgumentsHost);

      expect(sanitizationService.sanitizeContext).toHaveBeenCalledWith(
        expect.objectContaining({
          requestId: 'test-request-id',
          userId: 'test-user-id',
          method: 'GET',
          url: '/api/test',
          statusCode: 400,
          errorName: 'HttpException',
          errorMessage: 'Test error',
        }),
      );

      expect(loggingService.error).toHaveBeenCalledWith(
        'Unhandled exception: HttpException',
        sanitizedContext,
      );
    });
  });
});
