import { Test, TestingModule } from '@nestjs/testing';
import { ExecutionContext, CallHandler } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { of, throwError } from 'rxjs';
import { BusinessEventLoggingInterceptor } from './business-event-logging.interceptor';
import { LoggingService } from '../services/logging.service';
import { ContextManager } from '../services/context-manager.service';
import { LogSanitizationService } from '../services/log-sanitization.service';
import { LOG_BUSINESS_EVENT_KEY, BusinessEventMetadata } from '../decorators/log-business-event.decorator';

describe('BusinessEventLoggingInterceptor', () => {
  let interceptor: BusinessEventLoggingInterceptor;
  let loggingService: jest.Mocked<LoggingService>;
  let contextManager: jest.Mocked<ContextManager>;
  let sanitizationService: jest.Mocked<LogSanitizationService>;
  let reflector: jest.Mocked<Reflector>;
  let mockExecutionContext: ExecutionContext;
  let mockCallHandler: CallHandler;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        BusinessEventLoggingInterceptor,
        {
          provide: Reflector,
          useValue: {
            get: jest.fn(),
          },
        },
        {
          provide: LoggingService,
          useValue: {
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn(),
          },
        },
        {
          provide: ContextManager,
          useValue: {
            getCurrentContext: jest.fn(),
          },
        },
        {
          provide: LogSanitizationService,
          useValue: {
            sanitizeObject: jest.fn(),
            sanitizeContext: jest.fn(),
          },
        },
      ],
    }).compile();

    interceptor = module.get<BusinessEventLoggingInterceptor>(BusinessEventLoggingInterceptor);
    reflector = module.get(Reflector);
    loggingService = module.get(LoggingService);
    contextManager = module.get(ContextManager);
    sanitizationService = module.get(LogSanitizationService);

    // Setup mock execution context
    mockExecutionContext = {
      getHandler: jest.fn().mockReturnValue({ name: 'testMethod' }),
      getClass: jest.fn().mockReturnValue({ name: 'TestController' }),
      switchToHttp: jest.fn().mockReturnValue({
        getRequest: () => ({
          method: 'POST',
          url: '/api/test',
          headers: { 'content-type': 'application/json' },
          body: { test: 'data' },
          query: { param: 'value' },
          params: { id: '123' },
        }),
      }),
    } as any;

    // Setup mock call handler
    mockCallHandler = {
      handle: jest.fn().mockReturnValue(of({ success: true })),
    } as any;

    // Setup default context
    contextManager.getCurrentContext.mockReturnValue({
      requestId: 'test-request-id',
      userId: 'test-user-id',
      correlationId: 'test-correlation-id',
    });

    // Setup default sanitization
    sanitizationService.sanitizeObject.mockImplementation((obj) => obj);
    sanitizationService.sanitizeContext.mockImplementation((obj) => obj);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('intercept', () => {
    it('should skip logging if no metadata is found', () => {
      reflector.get.mockReturnValue(undefined);

      const result = interceptor.intercept(mockExecutionContext, mockCallHandler);

      expect(mockCallHandler.handle).toHaveBeenCalled();
      expect(loggingService.info).not.toHaveBeenCalled();
      expect(loggingService.warn).not.toHaveBeenCalled();
      expect(loggingService.error).not.toHaveBeenCalled();
    });

    it('should log business event on successful execution', () => {
      const metadata: BusinessEventMetadata = {
        eventName: 'user_registration',
        description: 'User registered successfully',
        category: 'authentication',
        severity: 'medium',
        includeRequestData: true,
        includeUserContext: true,
      };

      reflector.get.mockReturnValue(metadata);

      interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe();

      expect(loggingService.warn).toHaveBeenCalledWith(
        'Business Event: user_registration',
        expect.objectContaining({
          eventName: 'user_registration',
          description: 'User registered successfully',
          category: 'authentication',
          severity: 'medium',
          methodName: 'testMethod',
          className: 'TestController',
          requestId: 'test-request-id',
          userId: 'test-user-id',
          status: 'success',
        }),
      );
    });

    it('should log business event with error on failure', () => {
      const metadata: BusinessEventMetadata = {
        eventName: 'user_registration',
        severity: 'high',
      };

      const error = new Error('Registration failed');
      (mockCallHandler.handle as jest.Mock).mockReturnValue(throwError(() => error));
      reflector.get.mockReturnValue(metadata);

      interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe({
        error: (err) => {
          expect(err).toBe(error);
        },
      });

      expect(loggingService.error).toHaveBeenCalledWith(
        'Business Event: user_registration',
        expect.objectContaining({
          eventName: 'user_registration',
          severity: 'high',
          status: 'error',
          error: {
            message: 'Registration failed',
            name: 'Error',
            stack: expect.any(String),
          },
        }),
      );
    });

    it('should log with appropriate severity levels', () => {
      const testCases = [
        { severity: 'low', expectedMethod: 'info' as const },
        { severity: 'medium', expectedMethod: 'warn' as const },
        { severity: 'high', expectedMethod: 'error' as const },
        { severity: 'critical', expectedMethod: 'error' as const },
      ];

      testCases.forEach(({ severity, expectedMethod }) => {
        const metadata: BusinessEventMetadata = {
          eventName: 'test_event',
          severity: severity as any,
        };

        reflector.get.mockReturnValue(metadata);

        interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe();

        expect(loggingService[expectedMethod]).toHaveBeenCalledWith(
          'Business Event: test_event',
          expect.objectContaining({
            severity,
          }),
        );
      });
    });

    it('should include request data when configured', () => {
      const metadata: BusinessEventMetadata = {
        eventName: 'test_event',
        includeRequestData: true,
        severity: 'low',
      };

      reflector.get.mockReturnValue(metadata);

      interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe();

      expect(loggingService.info).toHaveBeenCalledWith(
        'Business Event: test_event',
        expect.objectContaining({
          requestData: expect.objectContaining({
            method: 'POST',
            url: '/api/test',
            headers: { 'content-type': 'application/json' },
            body: { test: 'data' },
            query: { param: 'value' },
            params: { id: '123' },
          }),
        }),
      );
    });

    it('should include user context when configured', () => {
      const metadata: BusinessEventMetadata = {
        eventName: 'test_event',
        includeUserContext: true,
        severity: 'low',
      };

      reflector.get.mockReturnValue(metadata);

      interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe();

      expect(loggingService.info).toHaveBeenCalledWith(
        'Business Event: test_event',
        expect.objectContaining({
          userContext: expect.objectContaining({
            userId: 'test-user-id',
          }),
        }),
      );
    });

    it('should include custom fields when provided', () => {
      const metadata: BusinessEventMetadata = {
        eventName: 'test_event',
        customFields: {
          customField1: 'value1',
          customField2: 123,
        },
        severity: 'low',
      };

      reflector.get.mockReturnValue(metadata);

      interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe();

      expect(loggingService.info).toHaveBeenCalledWith(
        'Business Event: test_event',
        expect.objectContaining({
          customFields: {
            customField1: 'value1',
            customField2: 123,
          },
        }),
      );
    });

    it('should include response data when configured', () => {
      const metadata: BusinessEventMetadata = {
        eventName: 'test_event',
        includeResponseData: true,
        severity: 'low',
      };

      const responseData = { success: true, data: 'test' };
      (mockCallHandler.handle as jest.Mock).mockReturnValue(of(responseData));
      reflector.get.mockReturnValue(metadata);

      interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe();

      expect(loggingService.info).toHaveBeenCalledWith(
        'Business Event: test_event',
        expect.objectContaining({
          responseData: responseData,
        }),
      );
    });

    it('should handle missing context gracefully', () => {
      const metadata: BusinessEventMetadata = {
        eventName: 'test_event',
        severity: 'low',
      };

      contextManager.getCurrentContext.mockReturnValue(null);
      reflector.get.mockReturnValue(metadata);

      interceptor.intercept(mockExecutionContext, mockCallHandler).subscribe();

      expect(loggingService.info).toHaveBeenCalledWith(
        'Business Event: test_event',
        expect.objectContaining({
          requestId: undefined,
          userId: undefined,
          correlationId: undefined,
        }),
      );
    });
  });
});
