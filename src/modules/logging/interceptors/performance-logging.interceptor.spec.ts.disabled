import { Test, TestingModule } from '@nestjs/testing';
import { ExecutionContext, CallHandler } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { of, throwError } from 'rxjs';
import { PerformanceLoggingInterceptor } from './performance-logging.interceptor';
import { LoggingService } from '../services/logging.service';
import { ContextManager } from '../services/context-manager.service';
import { LogSanitizationService } from '../services/log-sanitization.service';
import { LOG_PERFORMANCE_KEY } from '../decorators/log-performance.decorator';

describe('PerformanceLoggingInterceptor', () => {
  let interceptor: PerformanceLoggingInterceptor;
  let loggingService: jest.Mocked<LoggingService>;
  let contextManager: jest.Mocked<ContextManager>;
  let sanitizationService: jest.Mocked<LogSanitizationService>;
  let reflector: jest.Mocked<Reflector>;

  const mockExecutionContext = {
    getHandler: jest.fn().mockReturnValue({ name: 'testMethod' }),
    getClass: jest.fn().mockReturnValue({ name: 'TestController' }),
    switchToHttp: jest.fn().mockReturnValue({
      getRequest: jest.fn().mockReturnValue({
        method: 'GET',
        url: '/test',
        headers: { 'user-agent': 'test-agent' },
      }),
      getResponse: jest.fn().mockReturnValue({
        statusCode: 200,
      }),
    }),
  } as unknown as ExecutionContext;

  const mockCallHandler = {
    handle: jest.fn(),
  } as CallHandler;

  beforeEach(async () => {
    const mockLoggingService = {
      logPerformance: jest.fn(),
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
    };

    const mockContextManager = {
      getCurrentContext: jest.fn().mockReturnValue({
        requestId: 'test-request-id',
        userId: 'test-user-id',
      }),
    };

    const mockSanitizationService = {
      sanitizeContext: jest.fn().mockImplementation((data) => data),
    };

    const mockReflector = {
      get: jest.fn(),
      getAllAndOverride: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PerformanceLoggingInterceptor,
        {
          provide: LoggingService,
          useValue: mockLoggingService,
        },
        {
          provide: ContextManager,
          useValue: mockContextManager,
        },
        {
          provide: LogSanitizationService,
          useValue: mockSanitizationService,
        },
        {
          provide: Reflector,
          useValue: mockReflector,
        },
      ],
    }).compile();

    interceptor = module.get<PerformanceLoggingInterceptor>(PerformanceLoggingInterceptor);
    loggingService = module.get(LoggingService);
    contextManager = module.get(ContextManager);
    sanitizationService = module.get(LogSanitizationService);
    reflector = module.get(Reflector);
  });

  describe('intercept', () => {
    it('should log performance metrics for successful execution', async () => {
      const metadata = {
        operationName: 'test_operation',
        description: 'Test operation',
        includeRequestData: true,
        includeResponseData: true,
        slowThreshold: 100,
      };

      reflector.get.mockReturnValue(metadata);
      (mockCallHandler.handle as jest.Mock).mockReturnValue(of('test result'));

      const result = await interceptor.intercept(mockExecutionContext, mockCallHandler).toPromise();

      expect(result).toBe('test result');
      expect(loggingService.logPerformance).toHaveBeenCalledWith(
        'test_operation',
        'METHOD_EXECUTION',
        expect.any(Number),
        expect.any(Object),
        expect.any(Object),
      );
    });

    it('should log performance metrics for failed execution', async () => {
      const metadata = {
        operationName: 'test_operation',
        description: 'Test operation',
        includeRequestData: true,
        includeResponseData: false,
        slowThreshold: 100,
      };

      const error = new Error('Test error');
      reflector.get.mockReturnValue(metadata);
      (mockCallHandler.handle as jest.Mock).mockReturnValue(throwError(() => error));

      try {
        await interceptor.intercept(mockExecutionContext, mockCallHandler).toPromise();
      } catch (e) {
        expect(e).toBe(error);
      }

      expect(loggingService.logPerformance).toHaveBeenCalledWith(
        'test_operation',
        'METHOD_EXECUTION',
        expect.any(Number),
        expect.any(Object),
        expect.any(Object),
      );
    });

    it('should not log when no metadata is present', async () => {
      reflector.get.mockReturnValue(undefined);
      (mockCallHandler.handle as jest.Mock).mockReturnValue(of('test result'));

      const result = await interceptor.intercept(mockExecutionContext, mockCallHandler).toPromise();

      expect(result).toBe('test result');
      expect(loggingService.logPerformance).not.toHaveBeenCalled();
    });

    it('should use default operation name when not provided', async () => {
      const metadata = {
        description: 'Test operation',
        includeRequestData: true,
        includeResponseData: true,
        slowThreshold: 100,
      };

      reflector.get.mockReturnValue(metadata);
      (mockCallHandler.handle as jest.Mock).mockReturnValue(of('test result'));

      await interceptor.intercept(mockExecutionContext, mockCallHandler).toPromise();

      expect(loggingService.logPerformance).toHaveBeenCalledWith(
        'TestController.testMethod',
        'METHOD_EXECUTION',
        expect.any(Number),
        expect.any(Object),
        expect.any(Object),
      );
    });

    it('should include request data when configured', async () => {
      const metadata = {
        operationName: 'test_operation',
        includeRequestData: true,
        includeResponseData: false,
      };

      reflector.get.mockReturnValue(metadata);
      (mockCallHandler.handle as jest.Mock).mockReturnValue(of('test result'));

      await interceptor.intercept(mockExecutionContext, mockCallHandler).toPromise();

      expect(loggingService.logPerformance).toHaveBeenCalledWith(
        'test_operation',
        'METHOD_EXECUTION',
        expect.any(Number),
        expect.any(Object),
        expect.any(Object),
      );
    });

    it('should include response data when configured', async () => {
      const metadata = {
        operationName: 'test_operation',
        includeRequestData: false,
        includeResponseData: true,
      };

      reflector.get.mockReturnValue(metadata);
      (mockCallHandler.handle as jest.Mock).mockReturnValue(of('test result'));

      await interceptor.intercept(mockExecutionContext, mockCallHandler).toPromise();

      expect(loggingService.logPerformance).toHaveBeenCalledWith(
        'test_operation',
        'METHOD_EXECUTION',
        expect.any(Number),
        expect.any(Object),
        expect.any(Object),
      );
    });

    it('should sanitize context data', async () => {
      const metadata = {
        operationName: 'test_operation',
        includeRequestData: true,
        includeResponseData: true,
      };

      reflector.get.mockReturnValue(metadata);
      (mockCallHandler.handle as jest.Mock).mockReturnValue(of('test result'));

      await interceptor.intercept(mockExecutionContext, mockCallHandler).toPromise();

      expect(sanitizationService.sanitizeContext).toHaveBeenCalled();
    });

    it('should handle missing context gracefully', async () => {
      const metadata = {
        operationName: 'test_operation',
        includeRequestData: true,
        includeResponseData: true,
      };

      contextManager.getCurrentContext.mockReturnValue(null);
      reflector.get.mockReturnValue(metadata);
      (mockCallHandler.handle as jest.Mock).mockReturnValue(of('test result'));

      await interceptor.intercept(mockExecutionContext, mockCallHandler).toPromise();

      expect(loggingService.logPerformance).toHaveBeenCalledWith(
        'test_operation',
        'METHOD_EXECUTION',
        expect.any(Number),
        expect.any(Object),
        expect.any(Object),
      );
    });
  });
});
