name: Deploy Portfolio Application (Docker on EC2 and S3/CloudFront)

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - staging
        - production
      deploy_backend:
        description: 'Deploy Backend Services'
        required: true
        default: true
        type: boolean
      deploy_frontend:
        description: 'Deploy Frontend Services'
        required: true
        default: true
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_BACKEND: portfolio-backend
  ECR_REPOSITORY_FRONTEND: portfolio-frontend

jobs:
  build-and-push-backend:
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch') && (github.event.inputs.deploy_backend == 'true' || (github.event_name != 'workflow_dispatch' && vars.DEFAULT_DEPLOY_BACKEND != 'false'))
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push backend image
      id: build
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        set -e  # Exit on any error
        
        # Build backend image
        echo "üî® Building backend image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG . || {
          echo "‚ùå Backend image build failed"
          exit 1
        }
        
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest . || {
          echo "‚ùå Backend latest image build failed"
          exit 1
        }
        
        # Push backend images
        echo "üì§ Pushing backend images..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG || {
          echo "‚ùå Backend image push failed"
          exit 1
        }
        
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest || {
          echo "‚ùå Backend latest image push failed"
          exit 1
        }
        
        echo "‚úÖ Backend images built and pushed successfully"
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  build-frontend:
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch') && (github.event.inputs.deploy_frontend == 'true' || (github.event_name != 'workflow_dispatch' && vars.DEFAULT_DEPLOY_FRONTEND != 'false'))
    outputs:
      build-completed: ${{ steps.build.outputs.build-completed }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        # Disable cache to avoid rollup native module issues

    - name: Install frontend dependencies
      run: |
        cd frontend
        # Force clean install to fix rollup native module issues
        echo "üßπ Cleaning node_modules and package-lock.json..."
        rm -rf node_modules package-lock.json
        
        echo "üì¶ Installing dependencies..."
        npm install
        
        echo "üîß Fixing rollup native modules..."
        # Force reinstall rollup and its native dependencies
        npm uninstall rollup @rollup/rollup-linux-x64-gnu
        npm install rollup@latest
        
        # Alternative fix: install specific rollup native module
        npm install @rollup/rollup-linux-x64-gnu --save-optional
        
        # Verify rollup works
        echo "‚úÖ Verifying rollup installation..."
        npx rollup --version

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Build frontend for production
      id: build
      run: |
        cd frontend
        # Load production environment variables
        echo "üìù Loading production environment variables..."
        cp production.env .env
        echo "‚úÖ Environment variables loaded from production.env"
        
        # Verify rollup is working
        npx rollup --version
        # Build frontend
        npm run build
        echo "‚úÖ Frontend build completed successfully"
        echo "build-completed=true" >> $GITHUB_OUTPUT

  deploy-frontend:
    needs: build-frontend
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch') && (github.event.inputs.deploy_frontend == 'true' || (github.event_name != 'workflow_dispatch' && vars.DEFAULT_DEPLOY_FRONTEND != 'false'))
    outputs:
      bucket-name: ${{ steps.deploy.outputs.bucket-name }}
      distribution-id: ${{ steps.deploy.outputs.distribution-id }}
      cloudfront-domain: ${{ steps.deploy.outputs.cloudfront-domain }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        # Disable cache to avoid rollup native module issues

    - name: Install frontend dependencies
      run: |
        cd frontend
        # Force clean install to fix rollup native module issues
        echo "üßπ Cleaning node_modules and package-lock.json..."
        rm -rf node_modules package-lock.json
        
        echo "üì¶ Installing dependencies..."
        npm install
        
        echo "üîß Fixing rollup native modules..."
        # Force reinstall rollup and its native dependencies
        npm uninstall rollup @rollup/rollup-linux-x64-gnu
        npm install rollup@latest
        
        # Alternative fix: install specific rollup native module
        npm install @rollup/rollup-linux-x64-gnu --save-optional
        
        # Verify rollup works
        echo "‚úÖ Verifying rollup installation..."
        npx rollup --version

    - name: Build frontend for production
      run: |
        cd frontend
        # Load production environment variables
        echo "üìù Loading production environment variables..."
        cp production.env .env
        echo "‚úÖ Environment variables loaded from production.env"
        
        # Verify rollup is working
        npx rollup --version
        # Build frontend
        npm run build
        echo "‚úÖ Frontend build completed successfully"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy frontend to S3 and CloudFront
      id: deploy
      run: |
        set -e  # Exit on any error
        
        # Get S3 bucket name from CDK output (pattern: portfolio-frontend-{account}-{region})
        AWS_REGION=$(aws configure get region || echo "us-east-1")
        BUCKET_NAME="portfolio-frontend-${AWS_ACCOUNT_ID:-$(aws sts get-caller-identity --query Account --output text)}-${AWS_REGION}"
        
        echo "üîç Debug information:"
        echo "  AWS Account ID: ${AWS_ACCOUNT_ID}"
        echo "  AWS Region: ${AWS_REGION}"
        echo "  S3 Bucket Name: ${BUCKET_NAME}"
        
        # Check if S3 bucket exists
        if aws s3 ls "s3://${BUCKET_NAME}" 2>/dev/null; then
          echo "‚úÖ S3 bucket exists: ${BUCKET_NAME}"
        else
          echo "‚ùå S3 bucket not found: ${BUCKET_NAME}"
          echo "Available buckets:"
          aws s3 ls | grep portfolio-frontend || echo "No portfolio-frontend buckets found"
        fi
        
        # Get CloudFront distribution ID from CDK output or use default
        # Try both S3 domain formats: s3.amazonaws.com and s3-website-{region}.amazonaws.com
        S3_DOMAIN_1="${BUCKET_NAME}.s3.${AWS_REGION}.amazonaws.com"
        S3_DOMAIN_2="${BUCKET_NAME}.s3-website-${AWS_REGION}.amazonaws.com"
        
        echo "üîç Looking for CloudFront distributions with origins:"
        echo "  - ${S3_DOMAIN_1}"
        echo "  - ${S3_DOMAIN_2}"
        
        DISTRIBUTION_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[0].DomainName=='${S3_DOMAIN_1}' || Origins.Items[0].DomainName=='${S3_DOMAIN_2}'].Id" --output text)
        
        if [ -z "$DISTRIBUTION_ID" ]; then
          echo "‚ùå CloudFront distribution not found for bucket: $BUCKET_NAME"
          echo "Available CloudFront distributions:"
          aws cloudfront list-distributions --query "DistributionList.Items[].{Id:Id,DomainName:Origins.Items[0].DomainName}" --output table || echo "Failed to list distributions"
          exit 1
        fi
        
        echo "üì¶ Deploying to S3 bucket: $BUCKET_NAME"
        echo "üåê CloudFront distribution: $DISTRIBUTION_ID"
        
        # Get CloudFront domain name
        CLOUDFRONT_DOMAIN=$(aws cloudfront get-distribution --id $DISTRIBUTION_ID --query 'Distribution.DomainName' --output text)
        echo "üåê CloudFront domain: $CLOUDFRONT_DOMAIN"
        
        # Sync files to S3
        aws s3 sync frontend/build/ s3://$BUCKET_NAME/ --delete || {
          echo "‚ùå S3 sync failed"
          exit 1
        }
        
        # Invalidate CloudFront cache
        echo "üîÑ Invalidating CloudFront cache..."
        aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*" || {
          echo "‚ùå CloudFront invalidation failed"
          exit 1
        }
        
        echo "‚úÖ Frontend deployed to S3 and CloudFront successfully"
        echo "bucket-name=$BUCKET_NAME" >> $GITHUB_OUTPUT
        echo "distribution-id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT
        echo "cloudfront-domain=$CLOUDFRONT_DOMAIN" >> $GITHUB_OUTPUT

  deploy-backend:
    needs: build-and-push-backend
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch') && (github.event.inputs.deploy_backend == 'true' || (github.event_name != 'workflow_dispatch' && vars.DEFAULT_DEPLOY_BACKEND != 'false'))
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Upload backend deployment files to EC2
      uses: appleboy/scp-action@v0.1.4
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        source: "docker-compose.backend.yml,production.env,scripts/smart-migration.sh"
        target: "/home/${{ secrets.EC2_USER }}/mmotion-portfolio/"

    - name: Deploy Backend to EC2
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          set -e  # Exit on any error
          
          # Update environment variables
          export ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          export ECR_REPOSITORY_BACKEND=${{ env.ECR_REPOSITORY_BACKEND }}
          export IMAGE_TAG=${{ github.sha }}
          
          # Test ECR access first
          echo "üîê Testing ECR access..."
          aws sts get-caller-identity || {
            echo "‚ùå AWS credentials test failed"
            exit 1
          }
          
          # Login to ECR with retry
          echo "üîë Logging into ECR..."
          ECR_LOGIN_SUCCESS=false
          for i in {1..3}; do
            if aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY; then
              echo "‚úÖ ECR login successful"
              ECR_LOGIN_SUCCESS=true
              break
            else
              echo "‚ùå ECR login attempt $i failed, retrying..."
              sleep 5
            fi
          done
          
          if [ "$ECR_LOGIN_SUCCESS" = false ]; then
            echo "‚ùå ECR login failed after 3 attempts"
            exit 1
          fi
          
          # Pull latest backend image with retry
          echo "üì• Pulling backend image..."
          IMAGE_PULL_SUCCESS=false
          for i in {1..3}; do
            if docker pull $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:latest; then
              echo "‚úÖ Backend image pulled successfully"
              IMAGE_PULL_SUCCESS=true
              break
            else
              echo "‚ùå Backend image pull attempt $i failed, retrying..."
              sleep 10
            fi
          done
          
          if [ "$IMAGE_PULL_SUCCESS" = false ]; then
            echo "‚ùå Backend image pull failed after 3 attempts"
            exit 1
          fi
          
          # Ensure project directory exists
          echo "üìÅ Setting up project directory..."
          mkdir -p /home/${{ secrets.EC2_USER }}/mmotion-portfolio
          cd /home/${{ secrets.EC2_USER }}/mmotion-portfolio
          
          # Copy production environment file
          if [ ! -f .env ]; then
            cp production.env .env || {
              echo "‚ùå Failed to copy production.env to .env"
              exit 1
            }
            echo "üìù Created .env file from production.env"
          fi
          
          # Stop existing backend containers
          echo "üõë Stopping existing backend containers..."
          docker-compose -f docker-compose.backend.yml down || echo "‚ö†Ô∏è No existing containers to stop"
          
          # Start backend services
          echo "üöÄ Starting backend services..."
          docker-compose -f docker-compose.backend.yml up -d || {
            echo "‚ùå Failed to start backend services"
            exit 1
          }
          
          # Wait for backend to be healthy
          echo "‚è≥ Waiting for backend to be healthy..."
          sleep 60
          
          # Run smart database migrations (only when needed)
          echo "üß† Running smart database migrations..."
          chmod +x scripts/smart-migration.sh
          
          # Try smart migration first
          if ./scripts/smart-migration.sh; then
            echo "‚úÖ Smart migration completed successfully"
          else
            echo "‚ùå All migration attempts failed"
            exit 1
          fi
          
          # Check backend health
          # echo "üè• Checking backend health..."
          # if curl -f http://localhost:3000/health; then
          #   echo "‚úÖ Backend health check passed"
          # else
          #   echo "‚ùå Backend health check failed"
          #   exit 1
          # fi
          
          # Clean up old images
          echo "üßπ Cleaning up old images..."
          docker image prune -f || echo "‚ö†Ô∏è Image cleanup failed, but continuing..."
          
          echo "‚úÖ Backend deployment completed successfully"

          # Setup Nginx HTTPS proxy for API
          echo "üîß Setting up Nginx HTTPS proxy..."
          
          # Create SSH key file
          echo "${{ secrets.EC2_SSH_KEY }}" > /tmp/portfolio-key.pem
          chmod 600 /tmp/portfolio-key.pem
          
          # Test SSH connection first
          ssh -o StrictHostKeyChecking=no -i /tmp/portfolio-key.pem ubuntu@34.228.198.131 "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed"
            exit 1
          }
          
          # Setup nginx via SSH
          ssh -o StrictHostKeyChecking=no -i /tmp/portfolio-key.pem ubuntu@34.228.198.131 << 'EOF'
          # Update system
          sudo apt update
          
          # Install nginx if not installed
          if ! command -v nginx &> /dev/null; then
            echo "üì¶ Installing nginx..."
            sudo apt install -y nginx
          fi
          
          # Install openssl if not installed
          if ! command -v openssl &> /dev/null; then
            echo "üì¶ Installing openssl..."
            sudo apt install -y openssl
          fi
          
          # Create SSL directory if it doesn't exist
          sudo mkdir -p /etc/ssl/private
          sudo mkdir -p /etc/ssl/certs
          
          # Generate self-signed SSL certificate
          echo "üîê Generating self-signed SSL certificate..."
          sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /etc/ssl/private/nginx-selfsigned.key \
            -out /etc/ssl/certs/nginx-selfsigned.crt \
            -subj "/C=US/ST=State/L=City/O=Organization/CN=34.228.198.131"
          
          # Set proper permissions
          sudo chmod 600 /etc/ssl/private/nginx-selfsigned.key
          sudo chmod 644 /etc/ssl/certs/nginx-selfsigned.crt
          
          # Create nginx configuration
          sudo tee /etc/nginx/sites-available/portfolio-api > /dev/null << 'NGINX_CONFIG'
          server {
              listen 80;
              server_name 34.228.198.131;
              return 301 https://$server_name$request_uri;
          }
          
          server {
              listen 443 ssl http2;
              server_name 34.228.198.131;
              
              ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
              ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
              
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
              ssl_prefer_server_ciphers off;
              ssl_session_cache shared:SSL:10m;
              ssl_session_timeout 10m;
              
              add_header 'Access-Control-Allow-Origin' '*' always;
              add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
              add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;
              add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range' always;
              
              if ($request_method = 'OPTIONS') {
                  add_header 'Access-Control-Allow-Origin' '*';
                  add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS';
                  add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';
                  add_header 'Access-Control-Max-Age' 1728000;
                  add_header 'Content-Type' 'text/plain; charset=utf-8';
                  add_header 'Content-Length' 0;
                  return 204;
              }
              
              location /api/ {
                  proxy_pass http://127.0.0.1:3000/api/;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_cache_bypass $http_upgrade;
                  proxy_read_timeout 300s;
                  proxy_connect_timeout 75s;
              }
              
              location /ws {
                  proxy_pass http://127.0.0.1:3000/ws;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
              
              location /health {
                  proxy_pass http://127.0.0.1:3000/health;
                  proxy_http_version 1.1;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
              
              location /api/docs {
                  proxy_pass http://127.0.0.1:3000/api/docs;
                  proxy_http_version 1.1;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
          }
          NGINX_CONFIG
          
          # Enable the site
          sudo ln -sf /etc/nginx/sites-available/portfolio-api /etc/nginx/sites-enabled/
          sudo rm -f /etc/nginx/sites-enabled/default
          
          # Test nginx configuration
          sudo nginx -t
          
          # Restart nginx
          sudo systemctl restart nginx
          sudo systemctl enable nginx
          
          echo "‚úÖ Nginx HTTPS proxy setup completed!"
          EOF || {
            echo "‚ö†Ô∏è Nginx setup failed, but continuing..."
          }
          
          # Clean up SSH key file
          rm -f /tmp/portfolio-key.pem

  # Frontend is now deployed in separate build-frontend and deploy-frontend jobs

  health-check:
    needs: [deploy-backend, deploy-frontend]
    runs-on: ubuntu-latest
    if: always() && (needs.deploy-backend.result == 'success' || needs.deploy-frontend.result == 'success')
    
    steps:
    - name: Health Check
      run: |
        set -e  # Exit on any error
        
        echo "üè• Starting health check..."
        sleep 30
        
        # Check backend health (if deployed)
        if [ "${{ needs.deploy-backend.result }}" == "success" ]; then
        echo "üîç Checking backend health..."
          BACKEND_URL="https://34.228.198.131/health"
          echo "üåê Testing backend URL: $BACKEND_URL"
          if curl -f -L --max-time 30 -k $BACKEND_URL; then
          echo "‚úÖ Backend health check passed"
        else
          echo "‚ùå Backend health check failed"
            echo "üîç Debug: Trying to get more info about the backend URL..."
            curl -I -k $BACKEND_URL || echo "Failed to get backend headers"
            # Don't exit on backend failure if frontend is working
          fi
        else
          echo "‚è≠Ô∏è Backend deployment skipped, skipping backend health check"
        fi
        
        # Check frontend health (if deployed)
        if [ "${{ needs.deploy-frontend.result }}" == "success" ]; then
        echo "üîç Checking frontend health..."
          FRONTEND_URL="https://${{ needs.deploy-frontend.outputs.cloudfront-domain }}"
          echo "üåê Testing frontend URL: $FRONTEND_URL"
          if curl -f -L --max-time 30 $FRONTEND_URL; then
          echo "‚úÖ Frontend health check passed"
        else
          echo "‚ùå Frontend health check failed"
            echo "üîç Debug: Trying to get more info about the frontend URL..."
            curl -I $FRONTEND_URL || echo "Failed to get frontend headers"
          exit 1
          fi
        else
          echo "‚è≠Ô∏è Frontend deployment skipped, skipping frontend health check"
        fi
        
        echo "‚úÖ Health check completed successfully"